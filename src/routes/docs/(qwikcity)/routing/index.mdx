---
title: Qwik City - Routage
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
---

# Routage

Le routage dans Qwik City est basÃ© sur un systÃ¨me de fichier comme [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/core-concepts/routing) ou [Remix](https://remix.run/docs/en/main/guides/routing). Les fichiers et les rÃ©pertoires dans le rÃ©pertoire `src/routes` ont un rÃ´le dans le routage de votre application.

- **ðŸ“‚ RÃ©pertoiresÂ :** DÃ©crit les segments d'URL Ã  mettre en correspondance par le routeur.
- **ðŸ“„ Fichiers index.Â :** Page/endpoint.
- **ðŸ–¼ï¸ Fichiers layout.Â :** Mise en page imbriquÃ©e/middleware.

## Routage basÃ© sur les rÃ©pertoires

Seuls les noms des rÃ©pertoires sont utilisÃ©s pour faire correspondre les requÃªtes entrantes aux pages/endpoints.

Par exemple, si vous avez un fichier Ã  cet endroit `src/routes/some/path/index.tsx`, il sera mis en correspondance avec le chemin de l'URL `https://example.com/some/path`.

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ contact/
    â”‚   â””â”€â”€ index.mdx         # https://example.com/contact
    â”œâ”€â”€ about/
    â”‚   â””â”€â”€ index.md          # https://example.com/about
    â”œâ”€â”€ docs/
    â”‚   â””â”€â”€ [id]/
    â”‚       â””â”€â”€ index.ts      # https://example.com/docs/1234
    â”‚                         # https://example.com/docs/anything
    â”œâ”€â”€ [...catchall]/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/anything/else/that/didnt/match
    â”‚
    â””â”€â”€ layout.tsx            # Cette mise en page est utilisÃ©e pour toutes les pages
```

- **`[id]`** est un rÃ©pertoire qui reprÃ©sente un segment de route dynamique, dans cet exemple `id` est le paramÃ¨tre de type string accessible par `getLocation().params.id`.
- **`[...catchall]`** est un rÃ©pertoire qui reprÃ©sente une route dynamique catch-all, dans cet exemple `catchall` est le paramÃ¨tre de type string accessible par `getLocation().params.id`.
- **les fichiers `index.tsx|mdx`** sont les pages/endpoints.
- **les fichiers `layout.tsx`** sont les mises en page.

### Segments de routes dynamiques

Des rÃ©pertoires spÃ©ciaux nommÃ©s avec des crochets, tels que `[paramName]` et `[...catchAll]` peuvent Ãªtre utilisÃ©s pour faire correspondre des segments de route qui sont dynamiquesÂ :

```
src/routes/blog/index.tsx â†’ /blog
src/routes/user/[username]/index.tsx â†’ /user/:username (/user/foo)
src/routes/post/[...all]/index.tsx â†’ /post/* (/post/2020/id/title)
```

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ blog/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/blog
    â”œâ”€â”€ post/
    â”‚   â””â”€â”€ [...all]/
    â”‚       â””â”€â”€ index.tsx     # https://example.com/post/2020/id/title
    â””â”€â”€ user/
        â””â”€â”€ [username]/
            â””â”€â”€ index.tsx     # https://example.com/user/foo
```

> Le dossier `[username]` peut Ãªtre n'importe lequel des milliers d'utilisateurs que vous avez dans votre base de donnÃ©es. Il serait peu pratique de crÃ©er une route pour chaque utilisateur. Au lieu de cela, nous devons dÃ©finir un paramÃ¨tre de route (une partie de l'URL) qui sera utilisÃ© pour extraire le `[username]`.

```tsx
// src/routes/user/[username]/index.tsx
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>Hello {loc.params.username}!</div>;
});
```

## Fichiers `index.`

A l'intÃ©rieur du rÃ©pertoire `src/routes`, tous les fichiers nommÃ©s `index` sont considÃ©rÃ©s comme des pages/endpoints, Qwik prend en charge les extensions suivantesÂ : `.ts`, `.tsx`, `.md` et `.mdx`.

Les pages/endpoints sont les nÅ“uds feuilles de l'arbre de routage, c'est-Ã -dire **les modules qui vont traiter la requÃªte et renvoyer une rÃ©ponse HTTP**.

### Page `index.tsx`

Lorsque `index.tsx` ou `index.ts` exporte un composant Qwik en tant qu'exportation par dÃ©faut, Qwik City rendra le composant et retournera une rÃ©ponse HTML en tant que page web.

```tsx
// src/routes/index.tsx
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hello World</h1>;
});
```

### Endpoint `index.tsx`

Un `index.ts` peut aussi accÃ©der directement Ã  la requÃªte HTTP et retourner une rÃ©ponse HTTP brute sans impliquer aucun composant Qwik. Ceci se fait en exportant une mÃ©thode `onRequest`, `onGet`, `onPost`, `onPut`  ou `onDelete` si vous voulez seulement gÃ©rer une requÃªte spÃ©cifique en fonction de sa mÃ©thode HTTP.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onGet = ({ json }) => {
  json(200, { message: 'Hello World' });
};
```

> Remarquez que dans le dernier exemple, il n'y a pas d'exportation par dÃ©faut. C'est parce que nous ne rendons pas un composant Qwik, mais plutÃ´t nous gÃ©rons la requÃªte directement et retournons une rÃ©ponse JSON. Ceci est utile pour implÃ©menter des API RESTful ou tout autre type de endpoint HTTP.

### Page + Endpoint

Comme vous pouvez le voir dans Qwik City il n'y a pas de sÃ©paration claire entre les pages et les endpoints, dans les deux cas, c'est un fichier `index.tsx` qui exporte un composant Qwik ou une mÃ©thode `onRequest`. Cependant, il est possible de combiner les deux approches. Par exemple, vous pouvez exporter une mÃ©thode `onRequest` qui va gÃ©rer la requÃªte, et ensuite rendre un composant Qwik.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onRequest = ({ headers, query, json }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hello World' });
  }
};

export default component$(async () => {
  return <h1>Hello World</h1>;
});
```

> Dans cet exemple, un gestionnaire de requÃªte mettra toujours l'entÃªte `Cache-Control` Ã  `private` et la page sera rendue comme une page HTML, mais si la requÃªte contient un paramÃ¨tre de requÃªte `format=json`, le endpoint retournera une rÃ©ponse JSON Ã  la place.

## Fichiers `layout.`

Les modules de mise en page sont trÃ¨s similaires aux fichiers `index`, les deux peuvent gÃ©rer les requÃªtes et rendre les composants Qwik, cependant, les mises en page sont conÃ§ues pour fonctionner comme un middleware, permettant de **partager l'interface utilisateur et la gestion des requÃªtes (middleware)** pour un ensemble de routes.

GÃ©nÃ©ralement, les diffÃ©rentes pages ont besoin d'un traitement commun pour les requÃªtes et partagent une certaine interface utilisateur. Par exemple, imaginez un site de tableau de bord oÃ¹ toutes les pages se trouvent dans le rÃ©pertoire `/admin/*`Â :

- **Gestion des requÃªtes partagÃ©esÂ :** Les cookies de la requÃªte doivent Ãªtre validÃ©s avant mÃªme de rendre la page, sinon, une page 401 vide sera rendue.
- **Interface utilisateur partagÃ©e :** Toutes les pages partagent une entÃªte commune affichant le nom et la photo de profil de l'utilisateur.

Au lieu de rÃ©pÃ©ter le mÃªme code dans chaque route, nous pouvons utiliser des mises en page pour rÃ©utiliser automatiquement les parties communes, et aussi pour ajouter des middleware Ã  la route.

Prenez ce rÃ©pertoire `src/routes` comme exempleÂ :

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ admin/
    â”‚   â”œâ”€â”€ layout.tsx  <-- Cette mise en page est utilisÃ©e pour toutes les pages sous /admin/*
    â”‚   â””â”€â”€ index.tsx
    â”œâ”€â”€ layout.tsx      <-- Cette mise en page est utilisÃ©e pour toutes les pages
    â””â”€â”€ index.tsx
```

### Mise en page de middleware

Puisque les mises en page peuvent implÃ©menter la gestion des requÃªtes avec `onRequest`, `onGet`, `onPost`, `onPut` ou `onDelete`, elles peuvent Ãªtre utilisÃ©es pour implÃ©menter un middleware, par exemple, pour valider les cookies de la requÃªte avant de rendre la page.

Pour la route `https://example.com/admin`, les mÃ©thodes `onRequest` seront exÃ©cutÃ©es dans l'ordre suivantÂ :

1. `onRequest` de `src/routes/layout.tsx`
2. `onRequest` de `src/routes/admin/layout.tsx`
3. Celui du composant `src/routes/admin/index.tsx`

### Mises en page imbriquÃ©es

Les mises en page **fournissent Ã©galement un moyen d'ajouter une interface utilisateur commune Ã  la page rendue**. Par exemple, si nous voulons ajouter une en-tÃªte commune Ã  toutes les routes, nous pouvons ajouter un composant `Header` Ã  la mise en page racine.

Pour l'exemple donnÃ©, les composants Qwik seront rendus dans l'ordre suivantÂ :

1. Le composant de `src/routes/layout.tsx`
2. Le composant de `src/routes/admin/layout.tsx`
3. Le composant de `src/routes/admin/index.tsx`

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## Request Event

Chaque gestionnaire de requÃªte, tel que `onRequest`, `onGet`, `onPost`, etc., se voit passer un objet `RequestEvent` comme premier argument du gestionnaire. L'objet `RequestEvent` contient des fonctions utilitaires et des propriÃ©tÃ©s permettant d'obtenir et de dÃ©finir des valeurs pour la requÃªte et la rÃ©ponse du serveur. Cet objet contient les propriÃ©tÃ©s suivantesÂ :

- `basePathname`Â : Le chemin de base de la requÃªte, qui peut Ãªtre configurÃ© au moment de la construction. La valeur par dÃ©faut est `/`.
- `cacheControl`Â : Convenience function to set the [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) response header.
- `cookie`Â : HTTP request and response [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies). Use the `get()` method to retrieve a request cookie value. Use the `set()` method to set a response cookie value.
- `env`Â : Platform provided environment variables.
- `error`Â : When called, the response will immediately end with the given status code. This could be useful to end a response with `404`, and use the 404 handler in the routes directory. See [Status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) for which status code should be used.
- `getWritableStream`Â : Low-level access to write to the HTTP response stream. Once `getWritableStream()` is called, the status and headers can no longer be modified and will be sent over the network.
- `headers`Â : HTTP [response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header).
- `html`Â : Convenience method to send an HTML body response. The response will be automatically set the `Content-Type` header to`text/html; charset=utf-8`. An `html()` response can only be called once.
- `json`Â : Convenience method to JSON stringify the data and send it in the response. The response will be automatically set the `Content-Type` header to`application/json; charset=utf-8`. A `json()` response can only be called once.
- `locale`Â : Which locale the content is in. The locale value can be retrieved from selected methods using `getLocale()`.
- `method`Â : HTTP request [method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) value.
- `next`Â : Call the next request handler. This is useful for middleware.
- `params`Â : URL path params which have been parsed from the current url pathname segments. Use `query` to instead retrieve the query string search params.
- `parseBody`Â : This method will check the request headers for a `Content-Type` header and parse the body accordingly. It supports `application/json`, `application/x-www-form-urlencoded`, and `multipart/form-data` content types. If the `Content-Type` header is not set, it will return `null`.
- `pathname`Â : URL pathname value. Does not include the protocol, domain, query string (search params) or hash.
- `platform`Â : Platform specific data and functions.
- `query`Â : URL query string [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) value. Use `params` to instead retrieve the route params found in the url pathname.
- `redirect`Â : URL to redirect to. When called, the response will immediately end with the correct redirect status and headers. See [Redirects](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) for which status code should be used.
- `request`Â : HTTP [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request).
- `send`Â : Send a body response. The `Content-Type` response header is not automatically set when using `send()` and must be set manually. A `send()` response can only be called once.
- `sharedMap`Â : Shared Map across all the request handlers. Every HTTP request will get a new instance of the shared map. The shared map is useful for sharing data between request handlers.
- `status`Â : HTTP response [status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). Sets the status code when called with an argument. Always returns the status code, so calling `status()` without an argument will can be used to return the current status code.
- `text`Â : Convenience method to send an text body response. The response will be automatically set the `Content-Type` header to`text/plain; charset=utf-8`. An `text()` response can only be called once.
- `url`Â : HTTP request [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL).

## Routage avancÃ©

Qwik City prend Ã©galement en chargeÂ :

- [ParamÃ¨tres de route](/docs/(qwikcity)/advanced/routing/index.mdx)
- [Mises en page imbriquÃ©es](/docs/(qwikcity)/advanced/routing/index.mdx#nested-layout)
- [Menus](/docs/(qwikcity)/advanced/menu/index.mdx)

Nous y reviendrons plus tard.
