---
title: Qwik City - Routage
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
---

# Routage

Le routage dans Qwik City est basÃ© sur un systÃ¨me de fichier comme [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/core-concepts/routing) ou [Remix](https://remix.run/docs/en/main/guides/routing). Les fichiers et les rÃ©pertoires dans le rÃ©pertoire `src/routes` ont un rÃ´le dans le routage de votre application.

- **ğŸ“‚ RÃ©pertoiresÂ :** DÃ©crit les segments d'URL Ã  mettre en correspondance par le routeur.
- **ğŸ“„ Fichiers index.Â :** Page/endpoint.
- **ğŸ–¼ï¸ Fichiers layout.Â :** Mise en page imbriquÃ©e/middleware.

## Routage basÃ© sur les rÃ©pertoires

Seuls les noms des rÃ©pertoires sont utilisÃ©s pour faire correspondre les requÃªtes entrantes aux pages/endpoints.

Par exemple, si vous avez un fichier Ã  cet endroit `src/routes/some/path/index.tsx`, il sera mis en correspondance avec le chemin de l'URL `https://example.com/some/path`.

```bash
src/
â””â”€â”€ routes/
    â”œâ”€â”€ contact/
    â”‚   â””â”€â”€ index.mdx         # https://example.com/contact
    â”œâ”€â”€ about/
    â”‚   â””â”€â”€ index.md          # https://example.com/about
    â”œâ”€â”€ docs/
    â”‚   â””â”€â”€ [id]/
    â”‚       â””â”€â”€ index.ts      # https://example.com/docs/1234
    â”‚                         # https://example.com/docs/anything
    â”œâ”€â”€ [...catchall]/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/anything/else/that/didnt/match
    â”‚
    â””â”€â”€ layout.tsx            # Cette mise en page est utilisÃ©e pour toutes les pages
```

- **`[id]`** est un rÃ©pertoire qui reprÃ©sente un segment de route dynamique, dans cet exemple `id` est le paramÃ¨tre de type string accessible par `getLocation().params.id`.
- **`[...catchall]`** est un rÃ©pertoire qui reprÃ©sente une route dynamique catch-all, dans cet exemple `catchall` est le paramÃ¨tre de type string accessible par `getLocation().params.id`.
- **les fichiers `index.tsx|mdx`** sont les pages/endpoints.
- **les fichiers `layout.tsx`** sont les mises en page.

### Segments de routes dynamiques

Des rÃ©pertoires spÃ©ciaux nommÃ©s avec des crochets, tels que `[paramName]` et `[...catchAll]` peuvent Ãªtre utilisÃ©s pour faire correspondre des segments de route qui sont dynamiquesÂ :

```
src/routes/blog/index.tsx â†’ /blog
src/routes/user/[username]/index.tsx â†’ /user/:username (/user/foo)
src/routes/post/[...all]/index.tsx â†’ /post/* (/post/2020/id/title)
```

```bash
src/
â””â”€â”€ routes/
    â”œâ”€â”€ blog/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/blog
    â”œâ”€â”€ post/
    â”‚   â””â”€â”€ [...all]/
    â”‚       â””â”€â”€ index.tsx     # https://example.com/post/2020/id/title
    â””â”€â”€ user/
        â””â”€â”€ [username]/
            â””â”€â”€ index.tsx     # https://example.com/user/foo
```

> Le dossier `[username]` peut Ãªtre n'importe lequel des milliers d'utilisateurs que vous avez dans votre base de donnÃ©es. Il serait peu pratique de crÃ©er une route pour chaque utilisateur. Au lieu de cela, nous devons dÃ©finir un paramÃ¨tre de route (une partie de l'URL) qui sera utilisÃ© pour extraire le `[username]`.

```tsx title="src/routes/user/[username]/index.tsx"
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>Hello {loc.params.username}!</div>;
});
```

## Fichiers `index.`

A l'intÃ©rieur du rÃ©pertoire `src/routes`, tous les fichiers nommÃ©s `index` sont considÃ©rÃ©s comme des pages/endpoints, Qwik prend en charge les extensions suivantesÂ : `.ts`, `.tsx`, `.md` et `.mdx`.

Les pages/endpoints sont les nÅ“uds feuilles de l'arbre de routage, c'est-Ã -dire **les modules qui vont traiter la requÃªte et renvoyer une rÃ©ponse HTTP**.

### Page `index.tsx`

Lorsque `index.tsx` ou `index.ts` exporte un composant Qwik en tant qu'exportation par dÃ©faut, Qwik City rendra le composant et retournera une rÃ©ponse HTML en tant que page web.

```tsx title="src/routes/index.tsx"
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hello World</h1>;
});
```

### Endpoint `index.ts`

Un `index.ts` peut aussi accÃ©der directement Ã  la requÃªte HTTP et retourner une rÃ©ponse HTTP brute sans impliquer aucun composant Qwik. Ceci se fait en exportant une mÃ©thode `onRequest`, `onGet`, `onPost`, `onPut`  ou `onDelete` si vous voulez seulement gÃ©rer une requÃªte spÃ©cifique en fonction de sa mÃ©thode HTTP.

```tsx title="src/routes/index.ts"
import { component$ } from '@builder.io/qwik';

export const onGet = ({ json }) => {
  json(200, { message: 'Hello World' });
};
```

> Remarquez que dans le dernier exemple, il n'y a pas d'exportation par dÃ©faut. C'est parce que nous ne rendons pas un composant Qwik, mais plutÃ´t nous gÃ©rons la requÃªte directement et retournons une rÃ©ponse JSON. Ceci est utile pour implÃ©menter des API RESTful ou tout autre type de endpoint HTTP.

### Page + Endpoint

Comme vous pouvez le voir dans Qwik City il n'y a pas de sÃ©paration claire entre les pages et les endpoints, dans les deux cas, c'est un fichier `index.tsx` qui exporte un composant Qwik ou une mÃ©thode `onRequest`. Cependant, il est possible de combiner les deux approches. Par exemple, vous pouvez exporter une mÃ©thode `onRequest` qui va gÃ©rer la requÃªte, et ensuite rendre un composant Qwik.

```tsx title="src/routes/index.ts"
import { component$ } from '@builder.io/qwik';

export const onRequest = ({ headers, query, json }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hello World' });
  }
};

export default component$(async () => {
  return <h1>Hello World</h1>;
});
```

> Dans cet exemple, un gestionnaire de requÃªte mettra toujours l'entÃªte `Cache-Control` Ã  `private` et la page sera rendue comme une page HTML, mais si la requÃªte contient un paramÃ¨tre de requÃªte `format=json`, le endpoint retournera une rÃ©ponse JSON Ã  la place.

## Fichiers `layout.`

Les modules de mise en page sont trÃ¨s similaires aux fichiers `index`, les deux peuvent gÃ©rer les requÃªtes et rendre les composants Qwik, cependant, les mises en page sont conÃ§ues pour fonctionner comme un middleware, permettant de **partager l'interface utilisateur et la gestion des requÃªtes (middleware)** pour un ensemble de routes.

GÃ©nÃ©ralement, les diffÃ©rentes pages ont besoin d'un traitement commun pour les requÃªtes et partagent une certaine interface utilisateur. Par exemple, imaginez un site de tableau de bord oÃ¹ toutes les pages se trouvent dans le rÃ©pertoire `/admin/*`Â :

- **Gestion des requÃªtes partagÃ©esÂ :** Les cookies de la requÃªte doivent Ãªtre validÃ©s avant mÃªme de rendre la page, sinon, une page 401 vide sera rendue.
- **Interface utilisateur partagÃ©e :** Toutes les pages partagent une entÃªte commune affichant le nom et la photo de profil de l'utilisateur.

Au lieu de rÃ©pÃ©ter le mÃªme code dans chaque route, nous pouvons utiliser des mises en page pour rÃ©utiliser automatiquement les parties communes, et aussi pour ajouter des middleware Ã  la route.

Prenez ce rÃ©pertoire `src/routes` comme exempleÂ :

```bash
src/
â””â”€â”€ routes/
    â”œâ”€â”€ admin/
    â”‚   â”œâ”€â”€ layout.tsx  <-- Cette mise en page est utilisÃ©e pour toutes les pages sous /admin/*
    â”‚   â””â”€â”€ index.tsx
    â”œâ”€â”€ layout.tsx      <-- Cette mise en page est utilisÃ©e pour toutes les pages
    â””â”€â”€ index.tsx
```

### Mise en page de middleware

Puisque les mises en page peuvent implÃ©menter la gestion des requÃªtes avec `onRequest`, `onGet`, `onPost`, `onPut` ou `onDelete`, elles peuvent Ãªtre utilisÃ©es pour implÃ©menter un middleware, par exemple, pour valider les cookies de la requÃªte avant de rendre la page.

Pour la route `https://example.com/admin`, les mÃ©thodes `onRequest` seront exÃ©cutÃ©es dans l'ordre suivantÂ :

1. `onRequest` de `src/routes/layout.tsx`
2. `onRequest` de `src/routes/admin/layout.tsx`
3. Celui du composant `src/routes/admin/index.tsx`

### Mises en page imbriquÃ©es

Les mises en page **fournissent Ã©galement un moyen d'ajouter une interface utilisateur commune Ã  la page rendue**. Par exemple, si nous voulons ajouter une en-tÃªte commune Ã  toutes les routes, nous pouvons ajouter un composant `Header` Ã  la mise en page racine.

Pour l'exemple donnÃ©, les composants Qwik seront rendus dans l'ordre suivantÂ :

1. Le composant de `src/routes/layout.tsx`
2. Le composant de `src/routes/admin/layout.tsx`
3. Le composant de `src/routes/admin/index.tsx`

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## EvÃ©nement de la requÃªte

Chaque gestionnaire de requÃªte, tel que `onRequest`, `onGet`, `onPost`, etc., se voit passer un objet `RequestEvent` comme premier argument du gestionnaire. L'objet `RequestEvent` contient des fonctions utilitaires et des propriÃ©tÃ©s permettant d'obtenir et de dÃ©finir des valeurs pour la requÃªte et la rÃ©ponse du serveur. Cet objet contient les propriÃ©tÃ©s suivantesÂ :

- `basePathname`Â : Le chemin de base de la requÃªte, qui peut Ãªtre configurÃ© au moment de la construction. La valeur par dÃ©faut est `/`.
- `cacheControl`Â : Fonction pratique pour dÃ©finir l'entÃªte de rÃ©ponse [Cache-Control](https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Cache-Control).
- `cookie`Â : Les [cookies](https://developer.mozilla.org/fr/docs/Web/HTTP/Cookies) de requÃªte et de rÃ©ponse HTTP. Utilisez la mÃ©thode `get()` pour rÃ©cupÃ©rer la valeur d'un cookie de requÃªte. Utilisez la mÃ©thode `set()` pour dÃ©finir la valeur d'un cookie de rÃ©ponse.
- `env`Â : Variables d'environnement fournies par la plateforme.
- `error`Â : Lorsqu'elle est appelÃ©e, la rÃ©ponse se terminera immÃ©diatement par le code de statut donnÃ©. Cela peut Ãªtre utile pour terminer une rÃ©ponse par `404`, et utiliser le gestionnaire 404 dans le rÃ©pertoire des routes. Voir les [Codes de statut](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) pour savoir quel code doit Ãªtre utilisÃ©.
- `getWritableStream`Â : AccÃ¨s de bas niveau pour Ã©crire dans le flux de rÃ©ponse HTTP. Une fois que `getWritableStream()` est appelÃ©, le statut et les entÃªtes ne peuvent plus Ãªtre modifiÃ©s et seront envoyÃ©s sur le rÃ©seau.
- `headers`Â : [EntÃªtes de rÃ©ponse](https://developer.mozilla.org/fr/docs/Glossary/Response_header) HTTP.
- `html`Â : MÃ©thode pratique pour envoyer un corps de rÃ©ponse HTML. La rÃ©ponse dÃ©finira automatiquement l'entÃªte `Content-Type` Ã  `text/html; charset=utf-8`. Une rÃ©ponse `html()` ne peut Ãªtre appelÃ©e qu'une seule fois.
- `json`Â : MÃ©thode pratique pour transformer les donnÃ©es en chaÃ®ne JSON et les envoyer dans la rÃ©ponse. La rÃ©ponse dÃ©finira automatiquement l'entÃªte `Content-Type` Ã  `application/json; charset=utf-8`. Une rÃ©ponse `json()` ne peut Ãªtre appelÃ©e qu'une seule fois.
- `locale`Â : Locale dans laquelle se trouve le contenu. La valeur locale peut Ãªtre rÃ©cupÃ©rÃ©e Ã  partir de mÃ©thodes sÃ©lectionnÃ©es en utilisant `getLocale()`.
- `method`Â : Valeur de la [mÃ©thode](https://developer.mozilla.org/fr/docs/Web/HTTP/Methods) de la requÃªte HTTP.
- `next`Â : Appelle le gestionnaire de requÃªte suivant. Ceci est utile pour le middleware.
- `params`Â : ParamÃ¨tres du chemin de l'URL qui ont Ã©tÃ© analysÃ©s Ã  partir des segments du chemin de l'URL actuelle. Utilisez `query` pour rÃ©cupÃ©rer les paramÃ¨tres de recherche de la chaÃ®ne de requÃªte.
- `parseBody`Â : Cette mÃ©thode vÃ©rifiera les entÃªtes de la requÃªte pour un entÃªte `Content-Type` et analysera le corps en consÃ©quence. Elle supporte les types de contenu `application/json`, `application/x-www-form-urlencoded` et `multipart/form-data`. Si l'entÃªte `Content-Type` n'est pas dÃ©fini, elle retournera `null`.
- `pathname`Â : Valeur du chemin d'accÃ¨s Ã  l'URL. Ne comprend pas le protocole, le domaine, la chaÃ®ne de requÃªte (paramÃ¨tres de recherche) ou le hachage.
- `platform`Â : DonnÃ©es et fonctions spÃ©cifiques Ã  la plateforme.
- `query`Â : Valeur de la chaÃ®ne de requÃªte [URLSearchParams](https://developer.mozilla.org/fr/docs/Web/API/URLSearchParams). Utilisez `params` pour rÃ©cupÃ©rer les paramÃ¨tres de la route trouvÃ©s dans le chemin de l'url.
- `redirect`Â : URL vers laquelle rediriger. Lorsqu'elle est appelÃ©e, la rÃ©ponse se termine immÃ©diatement avec le statut et les entÃªtes de redirection corrects. Voir les [Redirections](https://developer.mozilla.org/fr/docs/Web/HTTP/Redirections) pour savoir quel code statut doit Ãªtre utilisÃ©.
- `request`Â : [RequÃªte](https://developer.mozilla.org/fr/docs/Web/API/Request) HTTP (Request).
- `send`Â : Envoie un corps de rÃ©ponse. L'entÃªte de rÃ©ponse `Content-Type` n'est pas automatiquement dÃ©fini lors de l'utilisation de `send()` et doit Ãªtre dÃ©fini manuellement. Une rÃ©ponse `send()` ne peut Ãªtre appelÃ©e qu'une seule fois.
- `sharedMap`Â : Carte partagÃ©e par tous les gestionnaires de requÃªtes. Chaque requÃªte HTTP obtiendra une nouvelle instance de la carte partagÃ©e. La carte partagÃ©e est utile pour partager des donnÃ©es entre les gestionnaires de requÃªtes.
- `status`Â : [Code du statut](https://developer.mozilla.org/fr/docs/Web/HTTP/Status) de la rÃ©ponse HTTP. DÃ©finit le code de statut lorsqu'il est appelÃ© avec un argument. Renvoie toujours le code de statut, donc un appel Ã  `status()` sans argument peut Ãªtre utilisÃ© pour renvoyer le code de statut actuel.
- `text`Â : MÃ©thode pratique pour envoyer une rÃ©ponse texte du corps. La rÃ©ponse dÃ©finira automatiquement l'entÃªte `Content-Type` Ã  `text/plain ; charset=utf-8`. Une rÃ©ponse de `text()` ne peut Ãªtre appelÃ©e qu'une seule fois.
- `url`Â : [URL](https://developer.mozilla.org/fr/docs/Web/API/URL) de la requÃªte HTTP.

## Routage avancÃ©

Qwik City prend Ã©galement en chargeÂ :

- [ParamÃ¨tres de route](/docs/(qwikcity)/advanced/routing/index.mdx)
- [Mises en page imbriquÃ©es](/docs/(qwikcity)/advanced/routing/index.mdx#nested-layout)
- [Menus](/docs/(qwikcity)/advanced/menu/index.mdx)

Nous y reviendrons plus tard.
