---
title: Bonnes pratiques
contributors:
  - mhevery
  - the-r3aper7
  - manucorporat
  - jakovljevic-mladen
  - kerbelp
  - wfairclough
  - cunzaizhuyi
  - reemardelarosa
---

# Conseils pour Ã©viter l'hydratation

## N'enregistrez pas les Ã©vÃ©nements en avance avec `useVisibleTask$()`

> âš  Utilisez `useVisibleTask$()` avec prÃ©caution âš 

Au lieu de cela => mÃ©thodes `useOn()`

**Bonnes pratiques**Â :

```ts
useVisibleTask$(() => {
  const listener = (event) => {
    const mouseEvent = event as MouseEvent;
    console.log(mouseEvent.x, mouseEvent.y);
  };
  document.addEventListener('mousemove', listener);

  return () => {
    document.removeEventListener('mousemove', listener);
  };
});
```

**Pourquoi est-ce un problÃ¨me**Â :
Cela oblige plus de javascript Ã  se charger de maniÃ¨re anticipÃ©e, plutÃ´t que d'Ãªtre chirurgicalement rÃ©actif aux Ã©vÃ©nements de l'utilisateur. Plus de javascript en amont => performance de l'application plus lente.

Cela exige Ã©galement que vous, le dÃ©veloppeur, restiez plus attentif Ã  la relation entre le serveur et le client (il y a une raison pour laquelle vous avez obtenu `use > Visible < Task` aprÃ¨s tout).

Bien que cela soit parfois nÃ©cessaire, le framework devrait avoir pour mission de vous Ã©viter d'avoir Ã  vous en soucier autant que possible.

Sans parler du fait que cela demande un effort supplÃ©mentaire de votre part pour nettoyer manuellement l'Ã©couteur.

**Faites plutÃ´t cela**Â :

```ts
useOnDocument(
  'mousemove',
  $((event)=> {
    const mouseEvent = event as MouseEvent;
    console.log(mouseEvent.x, mouseEvent.y);
    // Aucun nettoyage manuel n'est nÃ©cessaireÂ !
  })
);
```

> REMARQUEÂ : Des hooks similaires existent pour window et les composants individuels.
> `window` -> `useOnWindow` , composant -> `useOn`
>
> - [docs useOn / useDocument / useWindow](https://qwik.builder.io/tutorial/hooks/use-on/)
> - [Exemple](https://qwik.builder.io/tutorial/hooks/use-on/#example)
> - [Tutoriel](https://qwik.builder.io/tutorial/events/programmatic/)

----

## Ne comptez pas sur `window` pour obtenir l'emplacement.

Au lieu de cela => `useLocation()`

**Bonnes pratiques**Â :

```ts
useVisibleTask$(()=> {
    if (window.location.href).includes('foo') {
        //... faire quelque chose
    }
})

//OU

//(Ã  la racine du composant)
if (typeof window !== "undefined") {
    const queryParams = new URLSearchParams(window.location.search);
    const query: Record<string, string> = {};
    queryParams.forEach((value, key) => {
        query[key] = value;
    })
    doTheThing(query);
}
```

**Pourquoi est-ce un problÃ¨me**Â :
De trÃ¨s nombreuses choses que vous ferez en rÃ©ponse aux informations de location peuvent facilement Ãªtre faites lors du rendu initial sur le serveur, et donneront un pur HTML sans surcharge JS.

Si vous forcez cette logique Ã  s'exÃ©cuter du cÃ´tÃ© client, cela introduit plus de JS en amont et provoque un chargement anticipÃ©.

Si vous utilisez le modÃ¨le `if typeof window !== "undefined"`, vous constaterez rapidement que ce code est simplement ignorÃ©. Il s'exÃ©cutera une fois sur le serveur et sautera le bloc de code parce que window sera toujours indÃ©fini sur le serveur. Vous Ãªtes habituÃ© Ã  ce que le code soit exÃ©cutÃ© deux fois. Qwik n'a pas besoin de le faire ! ðŸ˜Ž

**Faites plutÃ´t cela**Â :

```ts
const location = useLocation();

if (location.url.href.includes('foo')) {
  // faire quelque chose
}
//OU
doTheThing(location.url.searchParams);
```

## EXCEPTION

Lorsque vous utilisez SSG pour des fichiers purement statiques, c'est un mal nÃ©cessaire. Le serveur ne disposera pas d'informations sur l'emplacement actuel lorsqu'il gÃ©nÃ©rera les fichiers au moment de la construction.

Mais attention ! Si les informations dont vous avez besoin (par exemple, les paramÃ¨tres de requÃªte) ne sont pas nÃ©cessaires avant un Ã©vÃ©nement utilisateur, incluez plutÃ´t la vÃ©rification dans votre code de gestion des Ã©vÃ©nements pour Ã©viter le chargement anticipÃ© de JS.

> VoirÂ : les [docs de useLocation()](https://qwik.builder.io/docs/(qwikcity)/api/#uselocation)
