---
title: DÃ©marrage
contributors:
  - manucorporat
  - jesperp
  - adamdbradley
  - steve8708
  - cunzaizhuyi
  - mousaAM
  - zanettin
  - Craiqser
  - MyltsinVV
  - literalpie
  - colynyu
  - the-r3aper7
  - ahmadalfy
  - renomureza
  - mhevery
---

# DÃ©marrage avec Qwik

Qwik est un nouveau type de framework qui est [rÃ©sumable](../concepts/resumable/index.mdx) (pas de JS et pas d'hydratation), construit pour le Edge et [familier pour les dÃ©veloppeurs React](../cheat/qwik-react/index.mdx).

Si vous souhaitez jouer immÃ©diatement, essayez nos aires de jeux dans le navigateurÂ :
- [Stackblitz Qwik + Vite](https://qwik.new)
- [Exemples de terrains de jeux](/examples/reactivity/counter/)

## PrÃ©requis

Si vous souhaitez commencer Ã  utiliser Qwik localement, vous aurez besoin des Ã©lÃ©ments suivantsÂ :

- [Node.js v16.8](https://nodejs.org/en/download/) ou supÃ©rieur
- Votre IDE prÃ©fÃ©rÃ© ([vscode](https://code.visualstudio.com/) est recommandÃ©)
- Commencez par lire [Pensez Qwik](../think-qwik/index.mdx)

## CrÃ©ation d'une appli Ã  l'aide du CLI

La premiÃ¨re Ã©tape consiste Ã  crÃ©er une application Qwik avec notre CLI. Le CLI crÃ©era une application vierge afin que vous puissiez vous familiariser rapidement avec elle. Qwik prend en charge NPM, yarn et pnpm.

Lancez le CLI de Qwik dans votre shell. Choisissez le gestionnaire de paquets que vous prÃ©fÃ©rez et exÃ©cutez l'une des commandes suivantesÂ :

```shell
npm create qwik@latest
pnpm create qwik@latest
yarn create qwik
```

Le CLI vous guidera Ã  travers un menu interactif pour dÃ©finir le nom du projet, sÃ©lectionner l'un des _starters_ et vous demandera si vous voulez installer les dÃ©pendances. Pour en savoir plus sur les fichiers gÃ©nÃ©rÃ©s, lisez la [structure du projet](/docs/projet-structure/).

DÃ©marrez le serveur de dÃ©veloppement

```shell
npm start
pnpm start
yarn start
```

## Qwik Hello World

Pour vous familiariser avec Qwik, nous avons crÃ©Ã© un tutoriel d'application trÃ¨s simple "Hello World" qui aborde les concepts les plus importants de Qwik. Pour chaque partie abordÃ©e, nous vous renverrons Ã  la documentation correspondante oÃ¹ vous pourrez en savoir plus sur le concept en question.

Nous utiliserons https://icanhazdadjoke.com comme API pour obtenir une blague alÃ©atoire. Nous allons crÃ©er une application simple qui affichera une blague alÃ©atoire et un bouton pour obtenir une nouvelle blague.


## CrÃ©er une route

Tout commence par le service d'une page sur une route particuliÃ¨re. Construisons donc une application simple qui sert une blague alÃ©atoire sur la route `/joke/`. Qwikcity (le mÃ©ta-framework de Qwik) utilise le routage [basÃ© sur les rÃ©pertoires](/docs/routing/). Pour dÃ©buter :

1. CrÃ©ez un nouveau fichier `index.tsx` dans le rÃ©pertoire `src/routes/joke/` de votre projet. (Vous devrez d'abord crÃ©er le rÃ©pertoire `joke`).
2. Le fichier `index.tsx` de chaque route doit avoir un `export default component$(...)` pour que Qwikcity sache quel contenu servir. Collez le contenu suivant dans `src/routes/joke/index.tsx`Â :
  ```tsx
  import { component$ } from "@builder.io/qwik";

  export default component$(() => {
    return <div class="section bright">Une blagueÂ !</div>;
  });
  ```
3. Naviguez vers `http://127.0.0.1:5173/joke/` pour voir votre nouvelle page fonctionner.

REMARQUEÂ :
- Le composant par dÃ©faut de votre route `joke` est entourÃ© par une mise en page existante. Consultez [Mise en page](/docs/layout/) pour plus de dÃ©tails sur ce que sont les mises en page et sur la maniÃ¨re de les utiliser.
- Pour plus de dÃ©tails sur la crÃ©ation de composants, voir la section [API des composants](/docs/(qwik)/composants/overview/).


## Chargement des donnÃ©es

L'une des fonctions les plus courantes d'une page est de charger des donnÃ©es pour les afficher Ã  l'utilisateur. Cette opÃ©ration est rÃ©alisÃ©e Ã  l'aide de [chargeurs de routes](/docs/route-loader/).

1. Ouvrez `src/routes/joke/index.tsx` et ajoutez ce codeÂ :
  ```tsx
  import { routeLoader$ } from "@builder.io/qwik-city";

  const useDadJoke = routeLoader$(async () => {
    const response = await fetch("https://icanhazdadjoke.com/", {
      headers: { Accept: "application/json" },
    });
    return (await response.json()) as {
      id: string;
      status: number;
      joke: string;
    };
  });
  ```
2. Ensuite, ajoutez le hook `useDadJoke()` au composant `default` et utilisez le rÃ©sultat dans le JSXÂ :
  ```tsx
  export default component$(() => {
    const dadJokeSignal = useDadJoke();
    return (
      <div class="section bright">
        <div>{dadJokeSignal.value.joke}</div>
      </div>
    );
  });
  ```
3. Naviguez vers "http://127.0.0.1:5173/" pour voir l'application fonctionner.

Que fait le code ci-dessus ?
- La fonction passÃ©e Ã  `routeLoader$` est appelÃ©e sur le serveur par anticipation avant qu'un composant ne soit rendu et est responsable du chargement des donnÃ©es.
- Le `routeLoader$` renvoie un use-hook (`useDadJoke`) qui peut Ãªtre utilisÃ© dans le composant pour rÃ©cupÃ©rer les donnÃ©es du serveur.

REMARQUEÂ :
- Le `routeLoader$` est appelÃ© avec anticipation sur le serveur avant qu'un composant ne soit rendu, mÃªme si son use-hook n'est pas appelÃ© dans un composant.
- Le type de retour du `routeLoader$` est dÃ©duit dans le composant sans avoir besoin d'informations supplÃ©mentaires sur le type.

<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.tsx`:</summary>
```tsx
import { component$ } from "@builder.io/qwik";
import { routeLoader$ } from "@builder.io/qwik-city";

const useDadJoke = routeLoader$(async () => {
  const response = await fetch("https://icanhazdadjoke.com/", {
    headers: { Accept: "application/json" },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export default component$(() => {
  const dadJokeSignal = useDadJoke();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
    </div>
  );
});
```
</details>


## Envoi de donnÃ©es au serveur

PrÃ©cÃ©demment, nous avons utilisÃ© `routeLoader$` pour envoyer des donnÃ©es du serveur au client. Nous utilisons [`routeAction$`](/docs/action/) pour poster (envoyer) des donnÃ©es du client vers le serveur.

REMARQUEÂ : `routeAction$` est le meilleur moyen d'envoyer des donnÃ©es au serveur car il utilise l'API du formulaire natif du navigateur qui fonctionne mÃªme si JavaScript est dÃ©sactivÃ©.

Pour dÃ©clarer une actionÂ :

1. Ouvrez `src/routes/joke/index.tsx` et ajoutez ce codeÂ :
  ```tsx
  import {routeAction$, Form} from "@builder.io/qwik-city";

  const useJokeVoteAction = routeAction$((props) => {
    // Laissons au lecteur le soin de mettre cela en Å“uvre.
    console.log("VOTE", props);
  });
  ```

2. Mettez Ã  jour le `export default` du composant pour qu'il utilise le hook `useJokeVoteAction`. Pour ce faire, ajoutez l'Ã©lÃ©ment `<Form>`.

  ```tsx
  export default component$(() => {
    const dadJokeSignal = useDadJoke();
    const favoriteJokeAction = useJokeVoteAction();
    return (
      <div class="section bright">
        <div>{dadJokeSignal.value.joke}</div>
        <Form action={favoriteJokeAction}>
          <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
          <button name="vote" value="up">
            ğŸ‘
          </button>
          <button name="vote" value="down">
            ğŸ‘
          </button>
        </Form>
      </div>
    );
  });
  ```
3. Navigate to `http://127.0.0.1:5173/` to see the application running.

Que fait le code ci-dessusÂ ?
- `routeAction$` est utilisÃ© pour recevoir des donnÃ©es.
- La fonction passÃ©e Ã  `routeAction$` est appelÃ©e sur le serveur Ã  chaque fois que le formulaire est postÃ©.
  - La `routeAction$` renvoie un use-hook (`useJokeVoteAction`) qui peut Ãªtre utilisÃ© dans le composant postant les donnÃ©es du formulaire.
- `Form` est un composant de commoditÃ© qui enveloppe l'Ã©lÃ©ment natif `<form>` du navigateur.

Ã€ noter :
- Pour la validation, consultez la [validation de zod](/docs/action/#validation-de-zod).
  - La `routeAction$` fonctionne mÃªme si JavaScript est dÃ©sactivÃ©.
- Si JavaScript est activÃ©, le composant `Form` empÃªchera le navigateur d'afficher le formulaire et affichera Ã  la place les donnÃ©es en utilisant JavaScript et Ã©mulera le comportement natif du navigateur sans un rafraÃ®chissement complet.

<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.tsx`:</summary>
```tsx
import { component$ } from "@builder.io/qwik";
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from "@builder.io/qwik-city";
const useDadJoke = routeLoader$(async () => {
  const response = await fetch("https://icanhazdadjoke.com/", {
    headers: { Accept: "application/json" },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});
const useJokeVoteAction = routeAction$((props) => {
  console.log("VOTE", props);
});
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>
        {dadJokeSignal.value.joke}
      </div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          ğŸ‘
        </button>
        <button name="vote" value="down">
          ğŸ‘
        </button>
      </Form>
    </div>
  );
});
```
</details>

## Modification de l'Ã‰tat

Garder une trace de l'Ã©tat et mettre Ã  jour l'interface utilisateur est au coeur de ce que font les applications. Qwik fournit un hook `useSignal` pour garder une trace de l'Ã©tat de l'application. Pour en savoir plus, voir [gestion de l'Ã©tat](/docs/components/state/).

Pour dÃ©clarer l'Ã©tatÂ :
1. DÃ©clarer l'Ã©tat du composant en utilisant `useSignal()`.
   ```tsx
    const isFavoriteSignal = useSignal(false);
   ```
2. Ajoutez un bouton au composant qui modifiera l'Ã©tat.
   ```tsx
   <button onClick={() => isFavoriteSignal.value = !isFavoriteSignal.value}>
     {isFavoriteSignal.value ? "â¤ï¸" : "ğŸ¤"}
   </button>
   ```

REMARQUEÂ : 
- En cliquant sur le bouton, l'Ã©tat est mis Ã  jour et l'interface utilisateur est actualisÃ©e.

<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.tsx`:</summary>
```tsx
import { component$, useSignal } from "@builder.io/qwik";
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from "@builder.io/qwik-city";
const useDadJoke = routeLoader$(async () => {
  const response = await fetch("https://icanhazdadjoke.com/", {
    headers: { Accept: "application/json" },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});
const useJokeVoteAction = routeAction$((props) => {
  console.log("VOTE", props);
});
export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          ğŸ‘
        </button>
        <button name="vote" value="down">
          ğŸ‘
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? "â¤ï¸" : "ğŸ¤"}
      </button>
    </div>
  );
});
```
</details>

## TÃ¢ches et appel au code du serveur

Dans Qwik, une [tÃ¢che](/docs/components/lifecycle/#utilisez-usetask-lorsque-vous-avez-besoin-de) est un travail qui doit Ãªtre effectuÃ© lorsqu'un Ã©tat change (similaire Ã  un Â«Â effectÂ Â» dans d'autres frameworks). Dans cet exemple, nous utiliserons la tÃ¢che pour appeler du code sur le serveur.

1. CrÃ©ez une nouvelle tÃ¢che qui traque l'Ã©tat `isFavoriteSignal`Â :
   ```tsx
    useTask$(({ track }) => {
    });
   ```
2. Ajouter un appel Ã  `track` pour rÃ©-exÃ©cuter la tÃ¢che sur le changement d'Ã©tat de `isFavoriteSignal`Â :
   ```tsx
    useTask$(({ track }) => {
      track(isFavoriteSignal);
    });
   ```
3. Ajoutez le traitement que vous souhaitez exÃ©cuter lors d'un changement d'Ã©tatÂ :
   ```tsx
    useTask$(({ track }) => {
      track(isFavoriteSignal);
      console.log("FAVORITE (isomorphic)", isFavoriteSignal.value);
    });
   ```
4. Si vous voulez que le traitement se fasse uniquement sur le serveur, mettez-le dans `server$()`
   ```tsx
   useTask$(({ track }) => {
     track(isFavoriteSignal);
     console.log("FAVORITE (isomorphic)", isFavoriteSignal.value);
     server$(() => {
      console.log("FAVORITE (server)", isFavoriteSignal.value);
     })();
   });
   ```

REMARQUE :
- Notez que le corps de `useTask$` est exÃ©cutÃ© Ã  la fois sur le serveur et sur le client (isomorphique).
- Sur le serveur SSR, `FAVORITE (isomorphic) false` et `FAVORITE (server) false` sont affichÃ©s.
- Lorsque l'utilisateur interagit avec favorite, le client affiche `FAVORITE (isomorphic) true` et le serveur imprime `FAVORITE (server) false`.

<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.tsx`:</summary>
```tsx
import { component$, useSignal, useTask$ } from "@builder.io/qwik";
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from "@builder.io/qwik-city";
const useDadJoke = routeLoader$(async () => {
  const response = await fetch("https://icanhazdadjoke.com/", {
    headers: { Accept: "application/json" },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});
const useJokeVoteAction = routeAction$((props) => {
  console.log("VOTE", props);
});
export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(isFavoriteSignal);
    console.log("FAVORITE (isomorphic)", isFavoriteSignal.value);
    server$(() => {
      console.log("FAVORITE (server)", isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          ğŸ‘
        </button>
        <button name="vote" value="down">
          ğŸ‘
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? "â¤ï¸" : "ğŸ¤"}
      </button>
    </div>
  );
});
```
</details>

## Style

Le style est une partie importante de toute application. Qwik fournit un moyen d'associer et de dÃ©limiter les styles avec votre composant.

Pour ajouter des stylesÂ :
1. CrÃ©er un nouveau fichier `src/routes/joke/index.css`Â :
   ```css
   div {
     font-weight: bold;
   }
 
   form {
     float: right;
   }
   ```
2. Importez les styles dans `src/routes/joke/index.tsx`Â :
   ```tsx
   import STYLES from "./index.css?inline";
   ```
3. Indiquez au composant de charger les stylesÂ :
   ```tsx
   useStylesScoped$(STYLES);
   ```

REMARQUE :
- Le paramÃ¨tre de requÃªte `?inline` indique Ã  Vite d'intÃ©grer les styles dans le composant.
- L'appel `useStylesScoped$` indique Ã  Qwik d'associer les styles au composant uniquement (portÃ©e).
- Les styles ne sont chargÃ©s que s'ils ne sont pas dÃ©jÃ  intÃ©grÃ©s dans le cadre du SSR et uniquement pour le premier composant.


<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.css`:</summary>
```css
div {
  font-weight: bold;
}
form {
  float: right;
}
```
</details>
<details>
  <summary>POINT DE VÃ‰RIFICATIONÂ : `src/routes/joke/index.tsx`:</summary>
```tsx
import {
  component$,
  useSignal,
  useStylesScoped$,
  useTask$,
} from "@builder.io/qwik";
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from "@builder.io/qwik-city";
import STYLES from "./index.css?inline";
const useDadJoke = routeLoader$(async () => {
  const response = await fetch("https://icanhazdadjoke.com/", {
    headers: { Accept: "application/json" },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});
const useJokeVoteAction = routeAction$((props) => {
  console.log("VOTE", props);
});
export default component$(() => {
  useStylesScoped$(STYLES);
  const isFavoriteSignal = useSignal(false);
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(isFavoriteSignal);
    console.log("FAVORITE (isomorphic)", isFavoriteSignal.value);
    server$(() => {
      console.log("FAVORITE (server)", isFavoriteSignal.value);
    })();
  });
  return (
    <div class="section bright">
      <div>{dadJokeSignal.value.joke}</div>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          ğŸ‘
        </button>
        <button name="vote" value="down">
          ğŸ‘
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? "â¤ï¸" : "ğŸ¤"}
      </button>
    </div>
  );
});
```
</details>

## PrÃ©visualisation

Nous avons construit une application trÃ¨s simple qui vous a donnÃ© un aperÃ§u des concepts clÃ©s de Qwik et de l'API. L'application fonctionne en mode dev, qui utilise le hot-module-reloading (HMR) pour mettre Ã  jour continuellement l'application tout en changeant le code.

En mode dÃ©veloppement :
- Chaque fichier est chargÃ© individuellement, ce qui peut provoquer des cascades dans l'onglet rÃ©seau.
- Il n'y a pas de chargement spÃ©culatif des bundles, il peut donc y avoir un dÃ©lai lors de la premiÃ¨re interaction.

CrÃ©ons une version de production pour voir comment l'application sera livrÃ©e Ã  l'utilisateur et comment le problÃ¨me ci-dessus est rÃ©solu.

Pour crÃ©er une version de prÃ©visualisationÂ :
1. ExÃ©cutez `npm run preview` pour crÃ©er une version de production.

REMARQUE :
- Votre application devrait avoir une version de production et fonctionner sur un port diffÃ©rent.
- Si vous interagissez avec l'application maintenant, l'onglet rÃ©seau des outils de dÃ©veloppement devrait montrer que les bundles sont instantanÃ©ment livrÃ©s depuis le [cache du ServiceWorker](/docs/advanced/speculative-module-fetching/). 

## Bilan

FÃ©licitationsÂ ! Vous avez rÃ©ussi Ã  dÃ©buter. Cette vue d'ensemble est intentionnellement courte pour vous familiariser avec les diffÃ©rentes parties de Qwik. Nous vous recommandons de vous plonger dans les concepts ci-dessus pour en savoir plus. Voici quelques points clÃ©s Ã  retenirÂ :

- [Structure du projet](/docs/project-structure/)
- Routage [BasÃ© sur les rÃ©pertoires](/docs/routing/)
- [Composant](/docs/(qwik)/components/overview/)
- [Chargeurs de route](/docs/route-loader/)
- [Actions de formulaire](/docs/action/) (et [validation de zod](/docs/action/#validation-de-zod))
- [gestion de l'Ã©tat](/docs/components/state/)
- [tÃ¢ches](/docs/components/lifecycle/#use-usetask-when-you-need-to)
- [Cache du ServiceWorker](/docs/advanced/speculative-module-fetching/)
