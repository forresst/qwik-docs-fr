---
title: Règles de l'Optimiseur
contributors:
  - the-r3aper7
  - manucorporat
  - adamdbradley
---

# Optimiseur

La philosophie de Qwik est de retarder le chargement du code aussi longtemps que possible. Pour ce faire, Qwik s'appuie sur un Optimiseur pour réorganiser le code pour un chargement différé. L'Optimiseur est une transformation au niveau du code qui s'exécute pour synthétiser. (L'Optimiseur est écrit en Rust (et il est disponible comme WASM) pour une performance instantanée).

L'Optimizer recherche les `$` et applique une transformation qui extrait l'expression suivant le `$` et la transforme en un symbole importable et chargeable de manière différée.

Commençons par examiner un exemple simple de `Counter` :

```tsx
export const Counter = component$(() => {
  const store = useStore({ count: 0 });

  return <button onClick$={() => store.count++}>{store.count}</button>;
});
```

Le code ci-dessus représente ce qu'un développeur écrirait pour décrire le composant. Vous trouverez ci-dessous les transformations que l'Optimiseur applique au code pour le rendre chargeable de manière différée.

```tsx
const Counter = component(qrl('./chunk-a.js', 'Counter_onMount'));
```

`chunk-a.js`:

```tsx
export const Counter_onMount = () => {
  const store = useStore({ count: 0 });
  return <button onClick$={qrl('./chunk-b.js', 'Counter_onClick', [store])}>{store.count}</button>;
};
```

`chunk-b.js`:

```tsx
const Counter_onClick = () => {
  const [store] = useLexicalScope();
  return store.count++;
};
```

Remarquez que chaque occurrence de `$` entraîne la création d'un nouveau symbole chargeable de manière différée.

# `$` et les règles de l'Optimiseur

L'Optimiseur s'exécute dans la phase d'empaquetage de la construction de l'application. L'objectif de l'Optimiseur est de décomposer l'application en de nombreux petits morceaux pouvant être chargés de manière différée. L'Optimiseur déplace les expressions (généralement des fonctions) dans de nouveaux fichiers et laisse derrière lui une référence indiquant l'endroit où l'expression a été déplacée.

## La signification de `$`

L'Optimiseur doit savoir quelle expression doit être extraite dans un nouveau fichier. L'extraction d'un symbole est compliquée car la référence au symbole change entre le chargement direct et le chargement asynchrone. Cela signifie que l'Optimizer doit coopérer avec le runtime pour savoir quels symboles peuvent être extraits et comment le runtime peut ensuite les charger.

Examinons le problème hypothétique de l'action sur le scroll. Vous serez peut-être tenté d'écrire le code comme suit :

```tsx
function onScroll(fn: () => void) {
  document.addEventListener('scroll', fn);
}

onScroll(() => alert('scroll'));
```

Le problème avec cette approche est que le gestionnaire d'événement est chargé par avance, même si l'événement de scroll ne se déclenche jamais. Ce qu'il faut, c'est un moyen de référencer le code afin que cela permette un chargement différé.

Le développeur pourrait écrire :

```tsx
export scrollHandler = () => alert('scroll');

onScroll(() => (await import('./some-chunk')).scrollHandler());
```

Cela fonctionne mais représente beaucoup de travail. Le développeur doit placer le code dans un fichier différent et coder en dur le nom du morceau. À la place, nous utilisons l'Optimiseur pour effectuer ce travail automatiquement. Mais nous avons besoin d'un moyen pour indiquer à l'Optimiseur que nous voulons effectuer un tel réaménagement. pour cela, nous utilisons `$()` comme fonction de marquage.

```tsx
function onScroll(fnQrl: QRL<() => void>) {
  document.addEventListener('scroll', async () => {
    fn = await qImport(document, fnQrl);
    fn();
  });
}

onScroll($(() => alert('clicked')));
```

L'Optimiseur générera :

```tsx
onScroll(qrl('./chunk-a.js', 'onScroll_1'));
```

`chunk-a.js`:

```tsx
export const onScroll_1 = () => alert('scroll');
```

Remarques :

1. Tout ce que le développeur a dû faire, c'est envelopper la fonction dans le `$()` pour signaler à l'Optimiseur que la fonction doit être déplacée dans un nouveau fichier et donc chargée de manière différée.
2. Le `onScroll` a dû être implémenté légèrement différemment car il doit prendre en compte le fait que la `QRL` de la fonction doit être chargée avant de pouvoir être utilisée. En pratique, l'utilisation de `qImport` est rare dans les applications Qwik car le framework Qwik fournit des API de plus haut niveau qui ne demandent que rarement au développeur de travailler directement avec `qImport`.

Cependant, envelopper le code dans `$()` est un peu incommode. Pour cette raison, l'Optimiseur encapsule implicitement le premier argument de tout appel de fonction, qui se termine par `$`. (En outre, on peut utiliser `implicit$FirstArg()` pour effectuer automatiquement l'enveloppement et la correspondance de type de la fonction prenant le `QRL`).

```tsx
const onScroll$ = implicit$FirstArg(onScroll);

onScroll$(() => alert('scroll'));
```

Le développeur dispose désormais d'une syntaxe très simple pour exprimer qu'une fonction particulière doit être chargée de manière différée.

## Extraction de symbole

Supposons que vous ayez ce code :

```tsx
export const MyComp = component$(() => {
  /* la définition de mon composant */
});
```

L'Optimiseur décompose le code en deux fichiers :

Le fichier d'origine :

```tsx
const MyComp = component(qrl('./chunk-a.js', 'MyComp_onMount'));
```

`chunk-a.js`:

```tsx
export const MyComp_onMount = () => {
  /* la définition de mon composant */
};
```

Le résultat de l'Optimiseur est que la méthode `onMount` de `MyComp` a été extraite dans un nouveau fichier. Il y a quelques avantages à faire cela :

- Un composant Parent peut se référer à `MyComp` sans avoir besoin des détails d'implémentation de `MyComp`.
- L'application a maintenant plus de points d'entrée, ce qui donne au bundler plus de possibilités pour découper la base de code.

Consultez également : Capture de la portée lexicale.

# Capture de la portée lexicale

L'Optimiseur extrait les expressions (généralement des fonctions) dans de nouveaux fichiers et laisse derrière lui un `QRL` pointant vers l'emplacement du chargement différé.

Examinons un cas simple :

```tsx
export const Greeter = component$(() => {
  return <span>Hello World!</span>;
});
```

cela se traduira par :

```tsx
const Greeter = component(qrl('./chunk-a.js', 'Greeter_onMount'));
```

`chunk-a.js`:

```tsx
const Greeter_onMount = () => {
  return qrl('./chunk-b.js', 'Greeter_onRender');
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => <span>Hello World!</span>;
```

Ce qui précède concerne les cas simples où la closure de la fonction extraite ne capture aucune variable. Examinons un cas plus compliqué où la closure de la fonction extraite capture lexicalement des variables.

```tsx
export const Greeter = component$((props: { name: string }) => {
  const salutation = 'Hello';

  return (
    <span>
      {salutation} {props.name}!
    </span>
  );
});
```

La méthode naïve d'extraction des fonctions ne fonctionnera pas.

```tsx
const Greeter = component(qrl('./chunk-a.js', 'Greeter_onMount'));
```

`chunk-a.js`:

```tsx
const Greeter_onMount = (props) => {
  const salutation = 'Hello';
  return qrl('./chunk-b.js', 'Greeter_onRender');
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => (
  <span>
    {salutation} {props.name}!
  </span>
);
```

Le problème est visible dans le fichier `chunk-b.js`. La fonction extraite fait référence à `salutation` et `props`, qui ne sont plus dans la portée lexicale de la fonction. Pour cette raison, le code généré doit être légèrement différent.

`chunk-a.js`:

```tsx
const Greeter_onMount = (props) => {
  const salutation = 'Hello';
  return qrl('./chunk-b.js', 'Greeter_onRender', [salutation, props]);
};
```

`chunk-b.js`:

```tsx
const Greeter_onRender = () => {
  const [salutation, props] = useLexicalScope();

  return (
    <span>
      {salutation} {props.name}!
    </span>
  );
};
```

Remarquez deux changements :

1. La `QRL` de `Greeter_onMount` stocke maintenant `salutation` et `props`. Cela permet de capturer les constantes à l'intérieur des closures.
2. La closure générée `Greeter_onRender` a maintenant un préambule qui restaure `salutation` et `props` (`const [salutation, props] = useLexicalScope()`).

La capacité de l'Optimiseur (et du runtime Qwik) à capturer les constantes lexicalement scopées améliore significativement les fonctions qui peuvent être extraites dans les ressources chargées de manière différée. C'est un outil puissant pour décomposer des applications complexes en petits morceaux chargeables de manière différée.

# Règles de l'Optimiseur

Le travail de l'Optimiseur consiste à décomposer les grandes applications en de nombreux petits morceaux pouvant être chargés de manière différée.

L'Optimiseur peut charger de manière différée une closure de fonction, qui capture lexicalement les variables. Cependant, il y a des limites à ce qui peut être réalisé, et c'est pourquoi l'Optimiseur est livré avec un ensemble de règles.

Comme tout JavaScript valide n'est pas forcément du code de l'Optimiseur valide, gardez à l'esprit les règles suivantes :

- Toutes les variables capturées doivent être déclarées comme `const`.
- Toutes les variables capturées doivent être soit :
  - sérialisable
  - importable (soit `import` ou `export` dans ce fichier)

Le `$` n'est pas seulement un marqueur pour l'Optimiseur mais aussi un marqueur pour le développeur pour suivre ces règles.

> **REMARQUE** : Il y a une planification pour un « linter » qui sera capable d'appliquer ces règles avec anticipation.

## Imports

**RÈGLE** : Si une fonction extraite par l'Optimiseur fait référence à un symbole de niveau supérieur, ce symbole doit être importé ou exporté.

```tsx
import { importedFn } from '...';
export exportedFn = () => {...};

const salutation = "Hello";

someApi$(() => {
  importedFn(); // OK
  exportedFn(); // OK
  salutation; // Erreur : salutation non importée/exportée
})
```

La raison de la règle ci-dessus devient évidente lorsque l'on examine le résultat.

```tsx
import { importedFn } from '...';
export exportedFn = () => { ... };

const salutation = "Hello";

someApi(qrl('./chunk-a.js', 'someApi_1'));
```

`chunk-a.js`:

```tsx
import { importedFn } from '...';
import { exportedFn } from './originalFile';

export const someApi_1 = () => {
  importedFn(); // OK
  exportedFn(); // OK
  salutation; // Erreur : salutation non importée/exportée
};
```

## Closures

**RÈGLE** : Si une fonction capture lexicalement une variable (ou un paramètre), cette variable doit être (1) un `const` et (2) la valeur doit être sérialisable.

```tsx
function somefn() {
  let count = 0;
  list.foreach((item) => {
    count++;
    const currentCount = count;
    someApi$(() => {
      item; // OK (en supposant qu'il soit sérialisable)
      count; // ERREUR : count n'est pas un const
      currentCount; // OK (en supposant qu'il soit sérialisable)
    });
  });
}
```

Une fois de plus, l'examen du code généré révèle pourquoi ces règles doivent être ainsi :

```tsx
function somefn() {
  let count = 0;
  list.foreach((item) => {
    count++;
    const currentCount = count;
    someApi$(qrl('./chunk-a.js', '_1', [item, count, currentCount]));
  });
}
```

`chunk-a.js`:

```tsx
export _1 = () => {
  const [item, count, currentCount] = useLexicalScope();

  item; // OK (en supposant qu'il soit sérialisable)
  count; // ERREUR : count n'est pas un const
  currentCount; // OK (en supposant qu'il soit sérialisable)
};
```

Consultez la [sérialisation](../../../docs/concepts/resumable/index.mdx#serialization) pour une explication de ce qui est sérialisable.
