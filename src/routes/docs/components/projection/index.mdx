---
title: Projection
contributors:
  - RATIU5
  - manucorporat
  - forresst
  - adamdbradley
---

# Projection de contenu

La projection de contenu permet à un composant de traiter les enfants JSX du composant comme une formulaire de saisie et de projeter ces enfants dans le JSX du composant.

Exemple d'un composant pliable qui projette son contenu de manière conditionnelle.

```tsx
export const Collapsible = component$(() => {
  const store = useStore({ isOpen: true });

  return (
    <div class="collapsible">
      <div class="title" onClick$={() => (store.isOpen = !store.isOpen)}>
        <Slot name="title"></Slot>
      </div>
      {store.isOpen ? <Slot /> : null}
    </div>
  );
});
```

Le composant ci-dessus peut être utilisé à partir d'un composant parent comme celui-ci :

```tsx
export const MyApp = component$(() => {
  return (
    <Collapsible>
      <span q:slot="title">Texte du titre</span>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
    </Collapsible>
  );
});
```

Le composant `Collapsible` affichera toujours le titre, mais le corps du texte ne s'affichera que si `store.isOpen` est à `true`.

## Rendus en sortie

L'exemple ci-dessus se traduirait par ce HTML si `isOpen===true` :

```html
<my-app>
  <collapsible>
    <q:slot q:key="title" has-content>
      <span q:slot="title" has-content>Texte du titre</span>
    </q:slot>
    <q:slot>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vulputate accumsan pretium.
    </q:slot>
  </collapsible>
</my-app>
```

## Slots

Qwik utilise les slots comme un moyen de connection du contenu du composant parent à la projection de l'enfant.

Le composant parent utilise l'attribut `q:slot` pour identifier la source de la projection et l'élément `<Slot>` pour identifier la destination de la projection. Le contenu non nommé (ou non enveloppé) est supposé avoir l'attribut `q:slot=""`.

```tsx
export const Project = component$(() => {
  return (
    <div>
      <Slot />
    </div>
  );
});

export const MyApp = component$(() => {
  return (
    <Project>
      texte non enveloppé
      <span>texte enveloppé sans q:slot</span>
      <span q:slot="">texte enveloppé avec un nom par défaut</span>
    </Project>
  );
});
```

Le résultat :

```html
<my-app>
  <project>
    <div>
      <q:slot q:key has-content>
        texte non enveloppé
        <span>texte enveloppé sans q:slot</span>
        <span q:slot="">texte enveloppé avec un nom par défaut</span>
      </q:slot>
    </div>
  </project>
</my-app>
```

### Naming slots

Utilisez les attributs `q:slot` pour nommer les slots.

```tsx
export const Project = component$(() => {
  return (
    <div>
      <div class="title">
        <Slot name="title" />
      </div>
      <Slot />
    </div>
  );
});

export const MyApp = component$(() => {
  return (
    <Project>
      texte non enveloppé
      <span q:slot="title">texte du premier titre</span>
      <span>texte enveloppé sans q:slot</span>
      <span q:slot="title">texte du second titre</span>
    </Project>
  );
});
```

Le résultat :

```html
<my-app>
  <project>
    <div>
      <div class="title">
        <span q:slot="title">texte du premier titre</span>
        <span q:slot="title">texte du second titre</span>
      </div>
      <q:slot q:key="" has-content>
        texte non enveloppé
        <span>texte enveloppé sans q:slot</span>
      </q:slot>
    </div>
  </project>
</my-app>
```

Remarquez que :

- L'attribut `name=""` a le même comportement que l'absence d'attribut ou sans élément enveloppant.
- Les attributs multiples `q:slot="title"` regroupent les éléments dans la projection du contenu.

### Pas de projection de contenu

Qwik conserve tout le contenu autour, même s'il n'est pas projeté. C'est parce que le contenu pourrait être projeté dans le futur.

```tsx
export const Project = component$(() => {
  return <div />;
});

export const MyApp = component$(() => {
  return <Project>texte non enveloppé</Project>;
});
```

Le résultat :

```html
<my-app>
  <project>
    <q:template q:slot="">texte non enveloppé</q:template>
    <div></div>
  </project>
</my-app>
```

Remarquez que le contenu non projeté est déplacé dans un `<q:template>` inerte. Ceci est fait juste au cas où le composant `Project` effectue un re-rendu et insère un `<Slot>`. Dans ce cas, nous ne voulons pas avoir à refaire le rendu du composant parent juste pour générer le contenu projeté. En persistant le contenu non projeté lorsque le parent est initialement rendu, le rendu des deux composants peut rester indépendant.

### Contenu du slot par défaut

Il est possible d'insérer un contenu de slot par défaut si le composant parent ne fournit pas de valeur.

```tsx
export const Project = component$(() => {
  return (
    <>
      <Slot name="title">titre par défaut</Slot>
      <Slot>contenu par défaut</Slot>
    </>
  );
});

export const MyApp = component$(() => {
  return <Project>un certain contenu</Project>;
});
```

Le résultat :

```html
<my-app>
  <project>
    <q:slot q:key="title">
      <q:slot-default>titre par défaut</q:slot-default>
    </q:slot>
    <q:slot has-content>
      <q:slot-default>contenu par défaut</q:slot-default>
      un certain contenu
    </q:slot>
  </project>
</my-app>
```

Remarquez que le contenu par défaut peut être inclus dans le `<Slot>..contenu par défaut</Slot>`. Ce contenu sera toujours inséré dans la sortie HTML résultante enveloppée dans `<q:slot-default/>`. La visibilité du `<q:slot-default/>` est contrôlée par l'attribut `has-content`. Consultez la section CSS pour plus de détails.

## CSS

Pour que Qwik soit capable de rendre les composants indépendamment, il doit être capable de lire les règles de projection depuis le HTML. Ceci est réalisé avec les éléments `<q:slot>`, `<q:slot-default/>` et l'attribut `q:slot`. Ces éléments supplémentaires sont nécessaires pour y parvenir. Pour que les éléments soient inertes, Qwik ajoute le CSS suivant à la balise `<style>`.

```html
<style>
  q:slot,q:slot-default {
    /** Cela marque les éléments supplémentaires inertes pour flex, etc... **/
    display: contents;
  }
  q:slot.has-content > q:slot-default {
    /** Suppression de la valeur par défaut du Slot si le parent a fourni le contenu **/
    display: none:
  }
</style>
```

## Projection invalide

L'attribut `q:slot` doit être un enfant direct d'un composant.

```tsx
export const Project = component$(() => { ... })

export const MyApp = component$(() => {
  return (
    <Project>
      <span q:slot="title">ok, enfant direct de Project</span>
      <div>
        <span q:slot="title">Erreur, ce n'est pas un enfant direct de Project</span>
      </div>
    </Project>
  );
});
```

## Projection vs `children`

Tous les frameworks doivent permettre à un composant d'envelopper son contenu complexe de manière conditionnelle. Ce problème est résolu par de nombreuses manières, mais il existe deux approches prédominantes :

- **projection** : La projection est un moyen déclaratif de décrire comment le contenu passe du template parent à l'endroit où il doit être projeté.
- **`children`** : `children` fait référence aux approches vDOM qui traitent le contenu comme une autre entrée.

Les deux approches peuvent être décrites comme l'une déclarative et l'autre impérative. Elles ont toutes deux leur lot d'avantages et d'inconvénients.

Qwik utilise l'approche déclarative de la projection. La raison est que Qwik doit être capable de rendre les composants parents/enfants indépendamment les uns des autres. Avec une approche impérative (`children`), le composant enfant peut modifier le `children` d'innombrables façons. Si un composant enfant dépendait de `children`, il serait obligé d'effectuer un re-rendu à chaque fois qu'un composant parent effectuerait un re-rendu pour réappliquer la transformation impérative au `children`. Le rendu supplémentaire va explicitement à l'encontre des objectifs de rendu des composants Qwik dans leur isolation.

Reprenons l'exemple de notre `Collapsible` ci-dessus :

- Le parent doit être capable de changer le titre et le texte sans forcer le composant `Collapsible` à refaire un rendu. Qwik doit être capable de redistribuer les changements au template `MyApp` sans affecter le composant `Collapsible`.
- Le composant enfant a besoin de changer ce qui est projeté sans que le composant parent ne refasse de rendu. Dans notre cas, `Collapsible` doit être capable de montrer/cacher le `q:slot` par défaut sans charger et refaire le rendu du composant `MyApp`.

Pour que les deux composants aient un cycle de vie indépendant, la projection doit être déclarative. De cette façon, le parent ou l'enfant peuvent changer ce qui est projeté ou comment il est projeté sans que l'autre ne soit à nouveau rendu.

Avec l'approche `children`, le composant peut impérativement modifier les `children` de manière infinie. Cela rendrait extrêmement difficile la construction d'un framework qui ne forcerait pas à la fois le re-rendu du parent et des enfants.
