---
title: Cycles de vie
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Cycles de vie

<img src={diagram}/>

## Règles

Lorsque vous utilisez des hooks de cycle de vie, vous devez respecter les règles suivantes :

  - Ils ne peuvent être appelés que dans `component$`.
  - Ils ne peuvent être appelés qu'au niveau de la racine d'une fonction ou d'un contexte de fonction fléchée, et non à l'intérieur de branches ou de blocs conditionnels.
  - Ils ne peuvent être appelés qu'à partir d'une autre méthode `use*$`, ce qui permet la composition.

```tsx
useHook() // <-- ❌ ne fonctionne pas

export default component$(() => {
  useCustomHook() // <-- ✅ fonctionne
  if (condition) {
    useHook() // <-- ❌ ne fonctionne pas
  }
  const myQrl = $(() => useHook()) // <-- ❌ ne fonctionne pas
  return <button onClick$={() => useHook()}></button> // <-- ❌ ne fonctionne pas
})

const useCustomHook = () => {
  useHook() // <-- ✅ fonctionne
}
```

## `useMount$()`

`useMount$()` enregistre un hook à exécuter à la création du composant. `useMount$()` bloquera le rendu du composant jusqu'à ce que le callback `useMount$()` soit résolu. (Ceci est utile pour récupérer des données asynchrones et retarder le rendu jusqu'à ce que les données soient reçues, ce qui garantit que le composant rendu contienne les données).

Alors que `useMount$()` peut être exécuté sur le serveur ou le client, il ne s'exécute qu'une seule fois. (Soit sur le serveur, soit sur le client, selon l'endroit où le composant a été rendu pour la première fois).

Consultez également le hook `useServerMount$()` qui a la même sémantique mais ne fonctionne que sur le serveur.

### Exemple

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    // Ce code sera exécuté à la création du composant pour récupérer les données.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useServerMount$()`

`useServerMount$()` enregistre un hook monté sur le serveur qui s'exécute uniquement sur le serveur lorsque le composant est monté pour la première fois.

### Exemple

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useServerMount$(async () => {
    // Ce code sera exécuté QU'UNE SEULE FOIS dans le serveur, lorsque le composant sera monté.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useWatch$()`

Ré-exécute `watchFn` lorsque les saisies traquées changent.

Utilisez `useWatch` pour traquer les changements sur un ensemble de saisies, puis ré-exécutez `watchFn` lorsque ces saisies changent.

La fonction `watchFn` ne s'exécute que si les saisies traquées changent. Pour traquer les saisies, utilisez la fonction `track` pour envelopper les lectures de propriété. Cela créera des abonnements qui déclencheront la ré-exécution de `watchFn`.

Consultez également le hook `useClientEffect$()` qui a la même sémantique mais qui ne fonctionne que sur le client.

### Exemple

La fonction `useWatch` est utilisée pour observer la propriété `state.count`. Toute modification de la propriété `state.count` entraîne l'exécution de la fonction `watchFn` qui, à son tour, met à jour la propriété `state.doubleCount` pour obtenir le double de `state.count`.

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
    debounced: 0,
  });
  // Surveillance pour la mise à jour de doubleCount
  useWatch$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });
  // Surveillance pour la mise à jour de debounced
  useWatch$(({ track }) => {
    const doubleCount = track(() => store.doubleCount);
    const timer = setTimeout(() => {
      store.debounced = doubleCount;
    }, 2000);
    return () => {
      clearTimeout(timer);
    };
  });

  return (
    <>
      <div>
        {store.count} / {store.doubleCount}
      </div>
      <div>{store.debounced}</div>
    </>
  );
});
```

## `useClientEffect$()`

Ré-exécute le `watchFn` lorsque les saisies trackées changent.

Si aucun `track` n'est utilisé, il sera exécuté exactement une fois.

### Exemple

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // S'exécute uniquement dans le client
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```
