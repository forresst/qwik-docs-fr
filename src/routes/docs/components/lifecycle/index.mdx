---
title: Cycles de vie
keywords: useEffect, hooks
contributors:
  - nnelgxorz
  - RATIU5
  - manucorporat
---

import diagram from './diagram2.svg';

# Cycles de vie

## `useMount$()`

- **Déclencheur :** montage du composant
- **Quand :** avant le rendu et les ressources
- **Nombre de fois :** une seule fois par instance de composant
- **Plateforme :** serveur et navigateur

`useMount$()` enregistre un hook à exécuter à la création du composant. `useMount$()` bloquera le rendu du composant jusqu'à ce que le callback `useMount$()` soit résolu. (Ceci est utile pour récupérer des données asynchrones et retarder le rendu jusqu'à ce que les données soient reçues, ce qui garantit que le composant rendu contienne les données).

Alors que `useMount$()` peut être exécuté sur le serveur ou le client, il ne s'exécute qu'une seule fois. (Soit sur le serveur, soit sur le client, selon l'endroit où le composant a été rendu pour la première fois).

Consultez également le hook `useServerMount$()` qui a la même sémantique mais ne fonctionne que sur le serveur.

### Exemple

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useMount$(async () => {
    // Ce code sera exécuté à la création du composant pour récupérer les données.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

### Quand utiliser `useMount$()`

Vous voulez exécuter un code une seule fois, UNIQUEMENT lorsque le composant se monte.

## `useServerMount$()`

- **Déclencheur :** montage du composant
- **Quand :** avant le rendu et les ressources
- **Nombre de fois :** une seule fois par instance de composant
- **Plateforme :** serveur uniquement

`useServerMount$()` enregistre un hook monté sur le serveur qui s'exécute uniquement sur le serveur lorsque le composant est monté pour la première fois.

### Exemple

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    users: [],
  });
  useServerMount$(async () => {
    // Ce code sera exécuté QU'UNE SEULE FOIS dans le serveur, lorsque le composant sera monté.
    store.users = await db.requestUsers();
  });
  return (
    <>
      {store.users.map((user) => (
        <User user={user} />
      ))}
    </>
  );
});

interface User {
  name: string;
}

export function User(props: { user: User }) {
  return <div>Name: {props.user.name}</div>;
}
```

## `useWatch$()`

- **Déclencheur :** montage du composant et sur les changements d'état traqués
- **Quand :** avant le rendu et les ressources
- **Nombre de fois :** au moins une fois
- **Plateforme :** serveur et navigateur

Tout comme `useMount$()`, le hook est appelé la première fois que le composant se monte, mais il peut être appelé plusieurs fois si (et seulement si) il traque [un signal et un store](/docs/components/state/index.mdx) pour les changements.

> `useWatch$()` est différent de useEffect de React car `useWatch` s'exécute aussi pendant le SSR et avant le rendu.

### Exemple

La fonction `useWatch$()` est utilisée pour observer la propriété `state.count`. Toute modification de la propriété `state.count` entraîne l'exécution de la fonction `watchFn` qui, à son tour, met à jour la propriété `state.doubleCount` pour obtenir le double de `state.count`.

```tsx
import { component$, useStore, useWatch$ } from '@builder.io/qwik';

export const Cmp = component$(() => {
  const store = useStore({
    count: 1,
    doubleCount: 0,
  });

  useWatch$(({ track }) => {
    const count = track(() => store.count);
    store.doubleCount = 2 * count;
  });

  return (
    <>
      <div>
        {store.count} / {store.doubleCount}
      </div>
    </>
  );
});
```

L'exemple ci-dessus utilise la fonction `track` pour surveiller les changements dans `() => store.count`. Le callback sera exécuté une fois dans le SSR lorsque le composant est monté et à chaque fois que `store.count` change.

> Veuillez noter que `useWatch$()` s'exécute AVANT le rendu réel et dans le serveur, donc la manipulation manuelle du DOM doit être faite avec précaution.

> Voir aussi le hook `useClientEffect$()` qui partage une sémantique similaire mais qui ne s'exécute sur le client qu'après le rendu.


### Quand utiliser `useWatch$()`

Vous voulez faire muter un état, ou effectuer une action quand un état change. En d'autres termes, vous devez avoir des effets secondaires.

> Veuillez noter que si vous voulez charger des données (par exemple un fetch()), pour les utiliser plus tard dans votre composant, consultez [`useResource$()`](/docs/components/resource/index.mdx). Cette API sera encore plus efficace en utilisant le streaming SSR et le parallélisme.


## `useClientEffect$()`

- **Déclencheur :** montage du composant et sur les changements d'état traqués
- **Quand :** après le rendu
- **Nombre de fois :** au moins une fois
- **Plateforme :** navigateur uniquement

Similaire à `useWatch$()` ou `useMount$()`, ce hook sera également exécuté au moins une fois, mais il ne sera jamais exécuté sur le serveur, c'est-à-dire qu'il ne sera exécuté que dans le navigateur.

Pour tous les composants qui ont été montés pendant le SSR (dans le serveur), la fonction `useClientEffect$()` s'exécutera par avance, c'est-à-dire sans interaction de l'utilisateur, mais cette exécution par avance (eagarness) peut être configurée !

```tsx
useClientEffect$(() => console.log('s\'exécute dans le navigateur'), {
  eagarness: 'visible' // 'load' | 'visible' | 'idle'
});
```

C'est une caractéristique unique de Qwik, n'importe quel autre framework exécuterait ce code et d'autres dans le cadre de l'hydratation, mais dans Qwik, nous pouvons même spécifier quand cela se produit :

- `"visible"` : lorsque le composant devient visible dans la zone d'affichage (utilise sous le capot [l'observateur d'intersection](https://developer.mozilla.org/fr/docs/Web/API/Intersection_Observer_API)). Il s'agit de la valeur par défaut.
- `"load"` : à la fin du chargement des documents (événement « load » du document)
- `"idle"` : après le chargement au premier moment où le site devient inactif. Il utilise sous le capot [`requestIdleCallback()`](https://developer.mozilla.org/fr/docs/Web/API/Window/requestIdleCallback).

Comme `useWatch`

### Exemple

```tsx
export const Timer = component$(() => {
  const store = useStore({
    count: 0,
  });
  useClientEffect$(() => {
    // S'exécute uniquement dans le client
    const timer = setInterval(() => {
      store.count++;
    }, 500);
    return () => {
      clearInterval(timer);
    };
  });
  return <>{store.count}</>;
});
```

> **REMARQUE :** N'abusez pas de `useClientEffect$()` lorsque la même logique peut être réalisée en utilisant `useWatch$()` ou d'autres moyens. Posez-vous la question : Ce code doit-il vraiment être exécuté au début dans le navigateur ? Si la réponse est non, `useClientEffect$()` n'est probablement pas la bonne solution.

> Comment se compare-t-elle à la fonction `useEffect()` de React ? Les deux API partagent beaucoup de sémantique, mais alors que les deux s'exécutent APRÈS le rendu, `useClientEffect$()` peut aussi s'exécuter indépendamment du rendu.

### Quand utiliser `useClientEffect$()`

Vous devez exécuter le JS au moment du chargement de la page, même si l'utilisateur n'interagit jamais avec la page.

- Initialiser quelques animations
- logique WebGL
- Lire des `localStorage`
- Exécuter du code sans interaction de l'utilisateur


## Diagramme de flux

<img src={diagram}/>

## Règles de la méthode d'utilisation

Lorsque vous utilisez des hooks de cycle de vie, vous devez respecter les règles suivantes :

  - Ils ne peuvent être appelés que dans `component$`
  - Ils ne peuvent être appelés qu'au niveau de la racine d'une fonction / du contexte de la fonction fléchée, et non à l'intérieur de branches ou de blocs conditionnels.
  - Ils ne peuvent être appelés qu'à partir d'une autre méthode `use*$`, ce qui permet de faire des compositions.

```tsx
useHook() // <-- ❌ ne fonctionne pas

export default component$(() => {
  useCustomHook() // <-- ✅ fonctionne
  if (condition) {
    useHook() // <-- ❌ ne fonctionne pas
  }
  const myQrl = $(() => useHook()) // <-- ❌ ne fonctionne pas
  return <button onClick$={() => useHook()}></button> // <-- ❌ ne fonctionne pas
})

const useCustomHook = () => {
  useHook() // <-- ✅ fonctionne
}
```
