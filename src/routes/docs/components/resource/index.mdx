---
title: Ressources
contributors:
  - nnelgxorz
  - irfanullahjan
  - RATIU5
  - manucorporat
---

# useResource$()

Cette méthode vous permet de générer les valeurs calculées de manière asynchrone. La fonction asynchrone passée comme son premier argument sera appelée lorsque le composant sera monté et lorsque les valeurs traquées changeront.

Comme toutes les méthodes `use-`, elle doit être appelée dans le contexte de `component$()`, et toutes les [règles de hook s'appliquent](../../../docs/components/lifecycle/index.mdx#rules).

```tsx
const store = useStore({
  bar: 'foo'
})
const resource = useResource$(async (ctx) => {
  ctx.track(() => store.bar); // la ressource sera réexécutée lorsque store.bar sera modifié.
  ctx.track(() => props.url); // track() peut être appelé plusieurs fois, pour traquer plusieurs valeurs
  ctx.cleanup(() => {
    // Si la ressource doit être nettoyée, cette fonction sera appelée.
    // Permettant de nettoyer les ressources comme les timers, les abonnements, les requêtes de récupération, etc.
  });

  // cleanup() peut aussi être appelé plusieurs fois.
  ctx.cleanup(() => console.log('cleanup'));

  // Les ressources peuvent contenir des calculs asynchrones
  const value = await expensiveCompute(store.bar, props.url);
  return value;
});
```

Comme nous le voyons dans l'exemple ci-dessus, `useResouce$()` renvoie un objet `ResourceReturn<T>` qui fonctionne comme une promesse entièrement réactive améliorée, contenant les données et l'état de la ressource.

L'état `resource.state` peut être l'une des chaînes suivantes :

- `'pending'` - les données ne sont pas encore disponibles.
- `'resolved'` - les données sont disponibles.
- `'rejected'` - les données ne sont pas disponibles en raison d'une erreur ou d'un dépassement de délai.

Le callback passé à `useResource$()` s'exécute juste après que les callbacks `useMount$()` et `useWatch$()` se soient terminés. Veuillez vous référer à la section [Cycle de vie](../lifecycle/index.mdx) pour plus de détails.

## `<Resource />`

`<Resource />` est un composant qui assure le rendu de ses enfants lorsque la ressource est résolue, et assure un rendu de secours lorsque la ressource est en attente ou rejetée.

```tsx
  <Resource
    value={weatherResource}
    onPending={() => <div>Chargement...</div>}
    onRejected={() => <div>Impossible de charger la météo</div>}
    onResolved={(weather) => {
      return <div>Température : {weather.temp}</div>;
    }}
  />
```
Il est intéressant de noter que `<Resource />` n'est pas obligatoire lorsqu'on utilise `useResource$()`. C'est juste un moyen pratique de rendre l'état de la ressource.

### Exemples :
- #### `useResource$()` avec `<Resource />`

Exemple montrant comment `useResource$` est utilisé pour effectuer un appel pour requêter la météo lorsque le nom de la ville en saisie change.

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    city: '',
  });

  const weatherResource = useResource$<any>(async ({ track, cleanup }) => {
    const cityName = track(() => store.city);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
      signal: abortController.signal,
    });
    const data = res.json();
    return data;
  });

  return (
    <div>
      <input name="city" onInput$={(ev: any) => (store.city = ev.target.value)} />
      <Resource
        value={weatherResource}
        onPending={() => <div>Chargement...</div>}
        onResolved={(weather) => {
          return <div>Température : {weather.temp}</div>;
        }}
      />
    </div>
  );
});
```


- #### sans `<Resource />`

```tsx
export const Cmp = component$(() => {
  const store = useStore({
    city: '',
  });

  const weatherResource = useResource$<any>(async ({ track, cleanup }) => {
    const cityName = track(() => store.city);
    const abortController = new AbortController();
    cleanup(() => abortController.abort('cleanup'));
    const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
      signal: abortController.signal,
    });
    const data = res.json();
    return data;
  });

  return (
    <div>
      <input name="city" onInput$={(ev: any) => (store.city = ev.target.value)} />
      {weatherResource.state === 'pending' && (
        <div>Chargement...</div>
      )}
      {weatherResource.state === 'resolved' && (
        <div>Température : {weatherResource.resolved.temp}</div>
      )}
    </div>
  );
});
```

> **REMARQUE :**
> Nous recommandons fortement d'utiliser `<Resource />` chaque fois que cela est possible, car cela évitera les re-rendus du composant et c'est également optimisé pour SSR.
