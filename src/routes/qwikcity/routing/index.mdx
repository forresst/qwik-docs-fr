---
title: Qwik City - Routage
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
---

# Routage

Le routage dans Qwik City est basé sur un système de fichier comme [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/getting-started/what-is-solidstart) ou Remix. Les fichiers et les répertoires dans le répertoire `src/routes` ont un rôle dans le routage de votre application.

- **📂 Répertoires :** Décrit les segments d'URL à mettre en correspondance par le routeur.
- **📄 Fichiers index. :** Page/endpoint.
- **🖼️ Fichiers layout. :** Mise en page imbriquée/middleware.

## Routage basé sur les répertoires

Seuls les noms des répertoires sont utilisés pour faire correspondre les requêtes entrantes aux pages/endpoints.

Par exemple, si vous avez un fichier à cet endroit `src/routes/some/path/index.tsx`, il sera mis en correspondance avec le chemin de l'URL `https://example.com/some/path`.

```
src/
└── routes/
    ├── contact/
    │   └── index.mdx         # https://example.com/contact
    ├── about/
    │   └── index.md          # https://example.com/about
    ├── docs/
    │   └── [id]/
    │       └── index.ts      # https://example.com/docs/1234
    │                         # https://example.com/docs/anything
    ├── [...catchall]/
    │   └── index.tsx         # https://example.com/anything/else/that/didnt/match
    │
    └── layout.tsx            # Cette mise en page est utilisée pour toutes les pages
```

- **`[id]`** est un répertoire qui représente un segment de route dynamique, dans cet exemple `id` est le paramètre.
- **`[...catchall]`** est un répertoire qui représente une route dynamique catch-all, dans cet exemple `catchall` est le paramètre.
- **les fichiers `index.ext`** sont les pages/endpoints.
- **les ichiers `layout.ext`** sont les mises en page.

### Segments de routes dynamiques

Des répertoires spéciaux nommés avec des crochets, tels que `[paramName]` et `[...catchAll]` peuvent être utilisés pour faire correspondre des segments de route qui sont dynamiques :

```
src/routes/blog/index.tsx → /blog/:slug (/blog/hello-world)
src/routes/user/[username]/index.tsx → /user/:username/settings (/user/foo/)
src/routes/post/[...all]/index.tsx → /post/* (/post/2020/id/title)
```

```
src/
└── routes/
    ├── blog/
    │   └── index.tsx         # https://example.com/blog
    ├── post/
    │   └── [...all]/
    │       └── index.tsx     # https://example.com/post/2020/id/title/2020/12/03
    └── user/
        └── [username]/
            └── index.tsx     # https://example.com/user/foo
```

> Le dossier `[username]` peut être n'importe lequel des milliers d'utilisateurs que vous avez dans votre base de données. Il serait peu pratique de créer une route pour chaque utilisateur. Au lieu de cela, nous devons définir un paramètre de route (une partie de l'URL) qui sera utilisé pour extraire le `[username]`.

```tsx
// src/routes/user/[username]/index.tsx
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>Hello {loc.params.username}!</div>
});
```

## Fichiers `index.`

A l'intérieur du répertoire `src/routes`, tous les fichiers nommés `index` sont considérés comme des pages/endpoints, Qwik prend en charge les extensions suivantes : `.ts`, `.tsx`, `.md` et `.mdx`.

Les pages/endpoints sont les nœuds feuilles de l'arbre de routage, c'est-à-dire **les modules qui vont traiter la requête et renvoyer une réponse HTTP**.

### Page `index.tsx`

Lorsque `index.tsx` ou `index.ts` exporte un composant Qwik en tant qu'exportation par défaut, QwikCity rendra le composant et retournera une réponse HTML en tant que page web.

```tsx
// src/routes/index.tsx
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hello World</h1>;
});
```

### Endpoint `index.tsx`

Un `index.ts` peut aussi accéder directement à la requête HTTP et retourner une réponse HTTP brute sans impliquer aucun composant Qwik. Ceci est fait en exportant une méthode `onRequest`, `onGet`, `onPost`, `onPut`  ou `onDelete` si vous voulez seulement gérer une requête spécifique donnée par sa méthode HTTP.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onGet = ({ json }) => {
  json(200, { message: 'Hello World' });
};
```

> Remarquez que dans le dernier exemple, il n'y a pas d'exportation par défaut. C'est parce que nous ne rendons pas un composant Qwik, mais plutôt nous gérons la requête directement, et retournons une réponse JSON. Ceci est utile pour implémenter des API RESTful ou tout autre type de endpoint HTTP.

### Page + Endpoint

Comme vous pouvez le voir dans Qwik City il n'y a pas de séparation claire entre les pages et les endpoints, dans les deux cas c'est un fichier `index.tsx` qui exporte un composant Qwik ou une méthode `onRequest`. Cependant, il est possible de combiner les deux approches. Par exemple, vous pouvez exporter une méthode `onRequest` qui va gérer la requête, et ensuite rendre un composant Qwik.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onRequest = ({ headers, query }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hello World' });
  }
};

export default component$(async () => {
  return <h1>Hello World</h1>;
});
```

> Dans cet exemple, un gestionnaire de requête mettra toujours l'entête `Cache-Control` à `private` et la page sera rendue comme une page HTML, mais si la requête contient un paramètre de requête `format=json`, le endpoint retournera une réponse JSON à la place.

## Fichiers `layout.`

Les modules de mise en page sont très similaires aux fichiers `index`, les deux peuvent gérer les requêtes et rendre les composants Qwik, cependant, les mises en page sont conçues pour fonctionner comme un middleware, permettant de **partager l'interface utilisateur et la gestion des requêtes (middleware)** pour un ensemble de routes.

Généralement, les différentes pages ont besoin d'un traitement commun pour les requêtes, et partagent une certaine interface utilisateur. Par exemple, imaginez un site de tableau de bord où toutes les pages se trouvent dans le répertoire `/admin/*` :

- **Gestion des requêtes partagées :** Les cookies de la requête doivent être validés avant même de rendre la page, sinon une page 401 vide sera rendue.
- **Interface utilisateur partagée :** Toutes les pages partagent une entête commune affichant le nom et la photo de profil de l'utilisateur.

Au lieu de répéter le même code dans chaque route, nous pouvons utiliser des mises en page pour réutiliser automatiquement les parties communes, et aussi pour ajouter des middleware à la route.

Prenez ce répertoire `src/routes` comme exemple :

```
src/
└── routes/
    ├── admin/
    │   ├── layout.tsx  <-- Cette mise en page est utilisée pour toutes les pages sous /admin/*
    │   └── index.tsx
    ├── layout.tsx      <-- Cette mise en page est utilisée pour toutes les pages
    └── index.tsx
```

### Mise en page de middleware

Puisque les mises en page peuvent implémenter la gestion des requêtes avec `onRequest`, `onGet`, `onPost`, `onPut` ou `onDelete`, elles peuvent être utilisées pour implémenter un middleware, par exemple, pour valider les cookies de la requête avant de rendre la page.

Pour la route `https://example.com/admin`, les méthodes `onRequest` seront exécutées dans l'ordre suivant :

1. `onRequest` de `src/routes/layout.tsx`
2. `onRequest` de `src/routes/admin/layout.tsx`
3. Celui du composant `src/routes/admin/index.tsx`

### Mises en page imbriquées

Les mises en page **fournissent également un moyen d'ajouter une interface utilisateur commune à la page rendue**. Par exemple, si nous voulons ajouter une en-tête commune à toutes les routes, nous pouvons ajouter un composant `Header` à la mise en page racine.

Pour l'exemple donné, les composants Qwik seront rendus dans l'ordre suivant :

1. Le composant de `src/routes/layout.tsx`
2. Le composant de `src/routes/admin/layout.tsx`
3. Le composant de `src/routes/admin/index.tsx`

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## Routage avancé

Qwik City prend également en charge :

- [Paramètres de route](/qwikcity/advanced/routing/index.mdx)
- [Mises en page imbriquées](/qwikcity/advanced/routing/index.mdx#nested-layout)
- [Menus](/qwikcity/advanced/menu/index.mdx)

Nous y reviendrons plus tard.
