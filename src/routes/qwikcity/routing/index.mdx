---
title: Qwik City - Routage
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
---

# Routage

Le routage dans Qwik City est basÃ© sur un systÃ¨me de fichier comme [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/getting-started/what-is-solidstart) ou Remix. Les fichiers et les rÃ©pertoires dans le rÃ©pertoire `src/routes` ont un rÃ´le dans le routage de votre application.

- **ğŸ“‚ RÃ©pertoiresÂ :** DÃ©crit les segments d'URL Ã  mettre en correspondance par le routeur.
- **ğŸ“„ Fichiers index.Â :** Page/endpoint.
- **ğŸ–¼ï¸ Fichiers layout.Â :** Mise en page imbriquÃ©e/middleware.

## Routage basÃ© sur les rÃ©pertoires

Seuls les noms des rÃ©pertoires sont utilisÃ©s pour faire correspondre les requÃªtes entrantes aux pages/endpoints.

Par exemple, si vous avez un fichier Ã  cet endroit `src/routes/some/path/index.tsx`, il sera mis en correspondance avec le chemin de l'URL `https://example.com/some/path`.

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ contact/
    â”‚   â””â”€â”€ index.mdx         # https://example.com/contact
    â”œâ”€â”€ about/
    â”‚   â””â”€â”€ index.md          # https://example.com/about
    â”œâ”€â”€ docs/
    â”‚   â””â”€â”€ [id]/
    â”‚       â””â”€â”€ index.ts      # https://example.com/docs/1234
    â”‚                         # https://example.com/docs/anything
    â”œâ”€â”€ [...catchall]/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/anything/else/that/didnt/match
    â”‚
    â””â”€â”€ layout.tsx            # Cette mise en page est utilisÃ©e pour toutes les pages
```

- **`[id]`** est un rÃ©pertoire qui reprÃ©sente un segment de route dynamique, dans cet exemple `id` est le paramÃ¨tre.
- **`[...catchall]`** est un rÃ©pertoire qui reprÃ©sente une route dynamique catch-all, dans cet exemple `catchall` est le paramÃ¨tre.
- **les fichiers `index.ext`** sont les pages/endpoints.
- **les ichiers `layout.ext`** sont les mises en page.

### Segments de routes dynamiques

Des rÃ©pertoires spÃ©ciaux nommÃ©s avec des crochets, tels que `[paramName]` et `[...catchAll]` peuvent Ãªtre utilisÃ©s pour faire correspondre des segments de route qui sont dynamiquesÂ :

```
src/routes/blog/index.tsx â†’ /blog/:slug (/blog/hello-world)
src/routes/user/[username]/index.tsx â†’ /user/:username/settings (/user/foo/)
src/routes/post/[...all]/index.tsx â†’ /post/* (/post/2020/id/title)
```

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ blog/
    â”‚   â””â”€â”€ index.tsx         # https://example.com/blog
    â”œâ”€â”€ post/
    â”‚   â””â”€â”€ [...all]/
    â”‚       â””â”€â”€ index.tsx     # https://example.com/post/2020/id/title/2020/12/03
    â””â”€â”€ user/
        â””â”€â”€ [username]/
            â””â”€â”€ index.tsx     # https://example.com/user/foo
```

> Le dossier `[username]` peut Ãªtre n'importe lequel des milliers d'utilisateurs que vous avez dans votre base de donnÃ©es. Il serait peu pratique de crÃ©er une route pour chaque utilisateur. Au lieu de cela, nous devons dÃ©finir un paramÃ¨tre de route (une partie de l'URL) qui sera utilisÃ© pour extraire le `[username]`.

```tsx
// src/routes/user/[username]/index.tsx
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>Hello {loc.params.username}!</div>
});
```

## Fichiers `index.`

A l'intÃ©rieur du rÃ©pertoire `src/routes`, tous les fichiers nommÃ©s `index` sont considÃ©rÃ©s comme des pages/endpoints, Qwik prend en charge les extensions suivantesÂ : `.ts`, `.tsx`, `.md` et `.mdx`.

Les pages/endpoints sont les nÅ“uds feuilles de l'arbre de routage, c'est-Ã -dire **les modules qui vont traiter la requÃªte et renvoyer une rÃ©ponse HTTP**.

### Page `index.tsx`

Lorsque `index.tsx` ou `index.ts` exporte un composant Qwik en tant qu'exportation par dÃ©faut, QwikCity rendra le composant et retournera une rÃ©ponse HTML en tant que page web.

```tsx
// src/routes/index.tsx
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hello World</h1>;
});
```

### Endpoint `index.tsx`

Un `index.ts` peut aussi accÃ©der directement Ã  la requÃªte HTTP et retourner une rÃ©ponse HTTP brute sans impliquer aucun composant Qwik. Ceci est fait en exportant une mÃ©thode `onRequest`, `onGet`, `onPost`, `onPut`  ou `onDelete` si vous voulez seulement gÃ©rer une requÃªte spÃ©cifique donnÃ©e par sa mÃ©thode HTTP.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onGet = ({ json }) => {
  json(200, { message: 'Hello World' });
};
```

> Remarquez que dans le dernier exemple, il n'y a pas d'exportation par dÃ©faut. C'est parce que nous ne rendons pas un composant Qwik, mais plutÃ´t nous gÃ©rons la requÃªte directement, et retournons une rÃ©ponse JSON. Ceci est utile pour implÃ©menter des API RESTful ou tout autre type de endpoint HTTP.

### Page + Endpoint

Comme vous pouvez le voir dans Qwik City il n'y a pas de sÃ©paration claire entre les pages et les endpoints, dans les deux cas c'est un fichier `index.tsx` qui exporte un composant Qwik ou une mÃ©thode `onRequest`. Cependant, il est possible de combiner les deux approches. Par exemple, vous pouvez exporter une mÃ©thode `onRequest` qui va gÃ©rer la requÃªte, et ensuite rendre un composant Qwik.

```tsx
// src/routes/index.ts
import { component$ } from '@builder.io/qwik';

export const onRequest = ({ headers, query }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hello World' });
  }
};

export default component$(async () => {
  return <h1>Hello World</h1>;
});
```

> Dans cet exemple, un gestionnaire de requÃªte mettra toujours l'entÃªte `Cache-Control` Ã  `private` et la page sera rendue comme une page HTML, mais si la requÃªte contient un paramÃ¨tre de requÃªte `format=json`, le endpoint retournera une rÃ©ponse JSON Ã  la place.

## Fichiers `layout.`

Les modules de mise en page sont trÃ¨s similaires aux fichiers `index`, les deux peuvent gÃ©rer les requÃªtes et rendre les composants Qwik, cependant, les mises en page sont conÃ§ues pour fonctionner comme un middleware, permettant de **partager l'interface utilisateur et la gestion des requÃªtes (middleware)** pour un ensemble de routes.

GÃ©nÃ©ralement, les diffÃ©rentes pages ont besoin d'un traitement commun pour les requÃªtes, et partagent une certaine interface utilisateur. Par exemple, imaginez un site de tableau de bord oÃ¹ toutes les pages se trouvent dans le rÃ©pertoire `/admin/*`Â :

- **Gestion des requÃªtes partagÃ©esÂ :** Les cookies de la requÃªte doivent Ãªtre validÃ©s avant mÃªme de rendre la page, sinon une page 401 vide sera rendue.
- **Interface utilisateur partagÃ©e :** Toutes les pages partagent une entÃªte commune affichant le nom et la photo de profil de l'utilisateur.

Au lieu de rÃ©pÃ©ter le mÃªme code dans chaque route, nous pouvons utiliser des mises en page pour rÃ©utiliser automatiquement les parties communes, et aussi pour ajouter des middleware Ã  la route.

Prenez ce rÃ©pertoire `src/routes` comme exempleÂ :

```
src/
â””â”€â”€ routes/
    â”œâ”€â”€ admin/
    â”‚   â”œâ”€â”€ layout.tsx  <-- Cette mise en page est utilisÃ©e pour toutes les pages sous /admin/*
    â”‚   â””â”€â”€ index.tsx
    â”œâ”€â”€ layout.tsx      <-- Cette mise en page est utilisÃ©e pour toutes les pages
    â””â”€â”€ index.tsx
```

### Mise en page de middleware

Puisque les mises en page peuvent implÃ©menter la gestion des requÃªtes avec `onRequest`, `onGet`, `onPost`, `onPut` ou `onDelete`, elles peuvent Ãªtre utilisÃ©es pour implÃ©menter un middleware, par exemple, pour valider les cookies de la requÃªte avant de rendre la page.

Pour la route `https://example.com/admin`, les mÃ©thodes `onRequest` seront exÃ©cutÃ©es dans l'ordre suivantÂ :

1. `onRequest` de `src/routes/layout.tsx`
2. `onRequest` de `src/routes/admin/layout.tsx`
3. Celui du composant `src/routes/admin/index.tsx`

### Mises en page imbriquÃ©es

Les mises en page **fournissent Ã©galement un moyen d'ajouter une interface utilisateur commune Ã  la page rendue**. Par exemple, si nous voulons ajouter une en-tÃªte commune Ã  toutes les routes, nous pouvons ajouter un composant `Header` Ã  la mise en page racine.

Pour l'exemple donnÃ©, les composants Qwik seront rendus dans l'ordre suivantÂ :

1. Le composant de `src/routes/layout.tsx`
2. Le composant de `src/routes/admin/layout.tsx`
3. Le composant de `src/routes/admin/index.tsx`

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## Routage avancÃ©

Qwik City prend Ã©galement en chargeÂ :

- [ParamÃ¨tres de route](/qwikcity/advanced/routing/index.mdx)
- [Mises en page imbriquÃ©es](/qwikcity/advanced/routing/index.mdx#nested-layout)
- [Menus](/qwikcity/advanced/menu/index.mdx)

Nous y reviendrons plus tard.
