---
title: Prélecture de Qwik City
contributors:
  - ulic75
  - mhevery
  - adamdbradley
---

# Prélecture

Le but de la prélecture de Qwik n'est pas de prélever toute l'application, mais de prélever et mettre en cache ce qui est possible à ce moment là. Quand l'Optimiseur de Qwik décompose l'application, il est capable de comprendre les interactions possibles de l'utilisateur. Et à partir de cela, il est tout aussi important qu'il soit capable de comprendre ce qui n'est pas possible en fonction de l'interaction de l'utilisateur.

Par exemple, si une application complète rendue peut uniquement permettre de cliquer sur un bouton, cela signifie également que l'application complète ne pourra jamais être re-rendue. Comme Qwik est capable de comprendre ce qui est possible, et non possible, il est capable de collecter au mieux les bundles à précharger.

- [Prélecture et mise en cache avec un service worker](#prélecture-et-mise-en-cache-avec-un-service-worker)
- [Mise en cache des paires de requêtes et de réponses](#mise-en-cache-des-paires-de-requêtes-et-de-réponses)
- [Parallélisation des requêtes réseau](#parallélisation-des-requêtes-réseau)

## Prélecture par page

À chaque chargement de page, les bundles susceptibles d'être exécutés par l'utilisateur sont préchargés. Par exemple, disons que la page a un écouteur de clic sur un bouton. Lorsque la page se charge, la toute première chose que fait le service worker est de s'assurer que le bundle pour cet écouteur de clic est préchargé et en attente dans le [cache](/qwikcity/advanced/prefetching/index.mdx#mise-en-cache-des-paires-de-requêtes-et-de-réponses). Quand l'utilisateur clique sur le bouton, et que Qwik fait une requête au bundle de l'écouteur d'évènement, le but est que le bundle soit déjà dans le cache prêt à être exécuté.

## Prélecture par interaction

Vous pourriez penser que le chargement de la page est la première interaction de l'utilisateur, qui précharge l'éventuelle prochaine interaction de l'utilisateur. Lorsqu'une nouvelle interaction se produit, comme l'ouverture d'une modale, alors Qwik émettra à nouveau un autre événement de préchargement avec des bundles supplémentaires qui seront susceptibles d'être utilisés depuis la dernière interaction. La prélecture ne se produit pas seulement au chargement de la page mais se produit continuellement lorsque les utilisateurs interagissent avec l'application.

## Événement de prélecture

La stratégie de prélecture recommandée est d'utiliser un [service worker](/qwikcity/advanced/prefetching/index.mdx#prélecture-et-mise-en-cache-avec-un-service-worker) pour remplir le [Cache](https://developer.mozilla.org/fr/docs/Web/API/Cache) du navigateur. Qwik lui-même devra être configuré pour utiliser l'implémentation [prefetchEvent](../../../docs/advanced/prefetching/index.mdx#implémentation-de-la-prélecture), qui distribuera un évènement de prélecture.

L'événement `qprefetch` peut contenir diverses données détaillées sur ce qu'il faut prélever, telles que :

| Data      | Description                                                                                                      |
| --------- | ---------------------------------------------------------------------------------------------------------------- |
| `bundles` | Un tableau de noms de bundles JavaScript à précharger. Un "bundle" est une collection de symboles.               |
| `symbols` | Un tableau de symboles à précharger. Le service worker sait déjà de quels bundles chaque symbole fait partie. |
| `links`   | _Expérimental:_ Un tableau de liens `hrefs` à précharger.                                                        |

### Envoi d'un événement de prélecture

Ci-dessous, vous trouverez un exemple d'un événement de prélecture distribué. Ces événements sont envoyés par Qwik lui-même et ne nécessitent pas que les développeurs envoient ces événements manuellement. De plus, le [service worker](/qwikcity/advanced/prefetching/index.mdx#prélecture-et-mise-en-cache-avec-un-service-worker) ajoutera automatiquement des écouteurs pour ces événements.

```ts
dispatchEvent(new CustomEvent("qprefetch", { detail: {
  bundles: [...]
}}));
```

## Prélecture et mise en cache avec un service worker

Traditionnellement, un worker de service est utilisé pour précharger la plupart, voire la totalité, des bundles qu'une application utilise. Les [Service Workers](https://developer.mozilla.org/fr/docs/Web/API/Service_Worker_API/Using_Service_Workers) sont généralement vus comme un moyen de faire fonctionner une application hors ligne.

Qwik City, cependant, utilise les service workers très différemment pour fournir une stratégie puissante de préchargement et de mise en cache. Au contraire, le but n'est pas de charger l'application entière, mais plutôt d'utiliser le service worker pour précharger dynamiquement ce qui est _possible_ d'exécuter. En _ne préchargeant pas_ toute l'application, cela libère des ressources pour ne demander que les petites parties de l'appli qu'un utilisateur _pourrait_ utiliser en fonction de ce qu'il a sur son écran à ce moment-là.

### Tâche en arrière-plan

Un avantage de l'utilisation d'un service worker est qu'il s'agit également d'une extension d'un [worker](https://developer.mozilla.org/fr/docs/Web/API/Web_Workers_API), qui s'exécute dans un thread d'arrière-plan.

> Les Web Workers permettent d'exécuter une opération de script dans un thread d'arrière-plan distinct du thread d'exécution principal d'une application Web. L'avantage est que les traitements coûteux peuvent être exécutés dans un thread séparé, ce qui permet au thread principal (généralement l'interface utilisateur) de fonctionner sans être bloqué ou ralenti.

En déplaçant la logique de préchargement et de mise en cache vers un service worker (qui est un worker), nous sommes en mesure d'exécuter le code en tâche de fond, afin de ne pas interférer avec le thread principal de l'interface utilisateur. En n'interférant pas avec l'interface principale, nous sommes en mesure d'améliorer les performances de l'application Qwik pour les utilisateurs.

### Prélecture et mise en cache interactives

Qwik lui-même doit être configuré pour utiliser l'implémentation [prefetchEvent](../../../docs/advanced/prefetching/index.mdx#implémentation-de-la-prélecture) (qui est aussi la valeur par défaut de Qwik). Quand Qwik émet l'évènement [qprefetch](../../../docs/advanced/prefetching/index.mdx#implémentation-de-la-prélecture), l'enregistrement du service worker transmet activement les données de l'évènement prefetch au service worker installé et actif.

Le service worker précharge et met en cache les bundles souhaités en fonction de la demande. Le thread principal doit simplement émettre des données sur les bundles dont il peut avoir besoin, tandis que le service worker s'assure uniquement que les bundles sont mis en cache. Pour ce faire, le service worker pré-remplit le [Cache](https://developer.mozilla.org/fr/docs/Web/API/Cache) du navigateur.

1. Si le navigateur l'a déjà mis en cache ? Super, ne faites rien !
2. Si le navigateur n'a pas déjà mis en cache ce bundle, lançons la requête de récupération.

Pour en savoir plus sur la [Mise en cache des paires de requêtes et de réponses](/qwikcity/advanced/prefetching/index.mdx#mise-en-cache-des-paires-de-requêtes-et-de-réponses).

De plus, le service worker s'assure que plusieurs requêtes pour le même bundle ne se produisent pas en même temps. Pour en savoir plus, consultez la documentation [Parallélisation des requêtes réseau](#parallélisation-des-requêtes-réseau).

### Code utilisateur du service worker

Le service worker qui est installé est toujours entièrement contrôlé par le développeur. Par exemple, le fichier source `src/routes/service-worker.ts` devient `/service-worker.js`, qui est le script requêté par le navigateur. Remarquez comment sa place dans `src/routes` suit toujours le même modèle de routage basé sur les répertoires.

Voici un exemple de fichier source `src/routes/service-worker.ts` par défaut :

```ts
import { setupServiceWorker } from '@builder.io/qwik-city/service-worker';

setupServiceWorker();

addEventListener('install', () => self.skipWaiting());

addEventListener('activate', () => self.clients.claim());
```

Le code source de `src/routes/service-worker.ts` peut être modifié par le développeur comme il le souhaite. Cela inclut le fait d'accepter ou de refuser de mettre en place le service worker de Qwik City.

Remarquez que la fonction `setupServiceWorker()` est importée de `@builder.io/qwik-city/service-worker` et exécutée en haut du fichier source. Le développeur peut modifier l'appel de cette fonction à un autre moment ou de manière conditionnelle. Par exemple, le développeur peut vouloir gérer les requêtes de récupération en premier, auquel cas il ajoutera son propre écouteur de récupération au-dessus de `setupServiceWorker()`. Ou s'il ne veut pas du tout utiliser le service worker de Qwik City, il doit juste supprimer `setupServiceWorker()` du fichier.

De plus, le fichier `src/routes/service-worker.ts` par défaut est fourni avec des écouteurs d'événements [install](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/install_event) et [activate](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/activate_event), chacun étant ajouté en bas du fichier. Les callbacks fournis sont les callbacks recommandés. Cependant, le développeur peut les modifier en fonction des besoins de ses propres applis.

Une autre remarque importante est que l'interception des requêtes de Qwik City est _seulement_ pour les bundles Qwik, il ne tente pas de gérer les requêtes qui ne font pas partie de sa construction.

Donc, bien que Qwik City fournisse un moyen pour aider à précharger et mettre en cache les bundles, il ne prend pas le contrôle total du service worker de l'appli. Cela permet toujours aux développeurs d'ajouter leur logique de service worker sans entrer en conflit avec Qwik.

## Mise en cache des paires de requêtes et de réponses

Dans beaucoup de frameworks traditionnels, la stratégie préférée est d'utiliser `<link>` avec un attribut `rel` du type `prefetch`, `preload` ou `modulepreload`. Cependant, il y a [suffisamment de problèmes connus](#problèmes-connus-avec-link) pour que Qwik ne fasse pas de `link` la stratégie de préchargement par défaut (bien qu'elle puisse toujours être [configurée](../../../docs/advanced/prefetching/index.mdx)).

Au lieu de cela, Qwik préfère utiliser une approche plus récente qui tire pleinement profit de l'[API du cache](https://developer.mozilla.org/fr/docs/Web/API/Cache) du navigateur, qui est également mieux pris en charge que [modulepreload](#problèmes-connus-avec-link).

### API du cache

L'[API du cache](https://developer.mozilla.org/fr/docs/Web/API/Cache) est souvent associée au service workers, comme un moyen de stocker les paires de requêtes et de réponses afin qu'une application puisse travailler hors ligne. En plus de permettre aux applications de travailler sans connectivité, la même API du cache fournit un mécanisme extrêmement puissant de prélecture et de mise en cache disponible pour Qwik.

En utilisant le [service worker](/qwikcity/advanced/prefetching/index.mdx#prélecture-et-mise-en-cache-avec-un-service-worker) installé et activé pour intercepter les requêtes, Qwik est capable de gérer les requêtes spécifiques pour les bundles _connus_. Contrairement à la façon dont le service worker est utilisé par défaut, celle-ci ne tente pas de traiter toutes les requêtes, mais plutôt, seulement les bundles connus générés par Qwik.

Un avantage de l'Optimiseur de Qwik, c'est qu'il génère aussi un fichier `q-manifest.json`. Le manifeste fournit un graphe de module détaillé non seulement de la façon dont les bundles sont associés, mais aussi quels symboles sont dans chaque bundle. Ce même graphique de module est fourni au service worker qui permet à chaque requête réseau pour des bundles connus d'être traitée par le cache.

### Importations dynamiques et mise en cache

Quand Qwik demande un module, il utilise un `import()` dynamique. Par exemple, disons qu'une interaction avec l'utilisateur se produit, nécessitant que Qwik exécute un import dynamique pour `/build/q-abc.js`. Le code pour le faire ressemblerait à quelque chose comme ceci :

```ts
const module = await import('/build/q-abc.js');
```

Ce qui est important ici c'est que Qwik lui-même n'a aucune connaissance d'une stratégie de prélecture ou de mise en cache. Il fait simplement une requête pour une URL. Cependant, parce que nous avons installé un service worker, et que le service worker intercepte les requêtes, il est capable d'inspecter l'URL et de dire, « Regardez, c'est une requête pour `/build/q-abc.js` ! C'est l'un de nos bundles ! Vérifions d'abord si nous l'avons déjà dans le cache avant de faire une vraie demande au réseau ».

C'est là que la puissance du service worker et de l'API de cache entre en jeu ! Qwik pré-remplit d'abord le cache pour les modules que l'utilisateur pourrait bientôt demander dans un autre thread. Et mieux encore, si c'est déjà en cache, alors il n'y a pas besoin pour le navigateur de faire quoi que ce soit.

D'autres avantages incluent la [Parallélisation des requêtes réseau](#parallélisation-des-requêtes-réseau).

### Problèmes connus avec link

Le problème de l'approche link rel est l'absence de prise en charge sur _tous_ les appareils, du moins au moment de la rédaction du présent document. De plus, pendant le développement, il peut être trompeur de croire que cela fonctionne partout, alors que sur les appareils mobiles, il n'est pas facile de voir que la prélecture des liens fonctionne correctement.

> Prefetch est une fonctionnalité censée accélérer l'expérience de nos visiteurs, mais avec une mauvaise combinaison de navigateur et de CDN/serveur, elle peut rendre l'expérience plus lente !
>
> \- <cite><a href="https://andydavies.me/blog/2020/07/08/rel-equals-prefetch-and-the-importance-of-effective-http-slash-2-prioritisation/">Rel=prefetch et l'importance d'une priorisation efficace de HTTP/2</a></cite>

#### link rel="modulepreload"

- Même si c'est dans la spécification HTML, cela ne signifie pas que vos utilisateurs finaux préchargent votre appli correctement. [Puis-je utiliser : modulepreload](https://caniuse.com/link-rel-modulepreload)
- Non pris en charge par [Safari](https://bugs.webkit.org/show_bug.cgi?id=180574). Cela signifie que pour les utilisateurs d'iPhone et d'iPad (ceux qui pourraient bénéficier le plus de la prélecture), les modules ne seront pas préchargés.
- Non pris en charge par [Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1425310).

#### Requêtes en double

Il peut être possible de lancer des requêtes en double pour la même ressource. Par exemple, disons que nous voulons récupérer à l'avance `module-a.js`, et que pendant le chargement (qui peut prendre un temps court ou très long, nous ne le savons pas), l'utilisateur interagit avec l'appli, qui décide alors de demander et d'exécuter `module-a.js`. À l'heure où nous écrivons ces lignes, les navigateurs envoient souvent une deuxième requête, ce qui ne fait qu'empirer les choses.

L'approche du service worker peut [éviter cela](#parallélisation-des-requêtes-réseau) en identifiant une demande déjà en cours, en attendant que la première demande pour `module-a.js` se termine, puis en la clonant pour la deuxième demande. Cela signifie qu'une seule requête réseau se produira, même si de nombreux modules et prélectures peuvent appeler la même requête/réponse.

## Parallélisation des requêtes réseau

Dans les docs de [Mise en cache des paires de requêtes et de réponses](/qwikcity/advanced/prefetching/index.mdx#mise-en-cache-des-paires-de-requêtes-et-de-réponses), nous avons expliqué la puissante combinaison du [Cache](https://developer.mozilla.org/fr/docs/Web/API/Cache) et du [Service Worker](https://developer.mozilla.org/fr/docs/Web/API/ServiceWorker). Cependant, nous pouvons aller encore plus loin en veillant à ce que les requêtes en double ne soient pas créées pour le même bundle, et nous pouvons empêcher les phénomènes de cascade sur le réseau.

### Éviter les requêtes en double

Par exemple, disons qu'un utilisateur final dispose actuellement d'une connexion 3G lente. Quand il demande la page d'accueil, aussi vite que le permet ce réseau lent, l'appareil charge le HTML et rend le contenu (un domaine où Qwik se distingue vraiment). Sur cette connexion lente, ce serait une honte s'ils devaient aussi charger quelques centaines de kilobytes de plus juste pour [faire fonctionner leur appli et la rendre interactive](https://www.builder.io/blog/hydration-is-pure-overhead).

Cependant, parce que l'appli a été construite avec Qwik, l'utilisateur final n'a pas besoin de charger l'application complète pour qu'elle devienne interactive. Au lieu de cela, l'utilisateur final a déjà chargé l'appli HTML rendue par le SSR, et toutes les parties interactives, comme un bouton "Ajouter au panier", peuvent être préchargées immédiatement. Notez que nous ne préchargeons que le code de l'écouteur proprement dit, et _pas_ la pile entière des fonctions de rendu de l'arborescence des composants.

Dans cet exemple extrêmement courant dans le monde réel d'un appareil avec une connexion lente, l'appareil commence immédiatement à précharger les interactions possibles qui sont visibles par l'utilisateur final. Toutefois, en raison de la lenteur de la connexion, même si nous avons commencé à effectuer la prélecture dès que possible dans un [thread d'arrière-plan](#prélecture-et-mise-en-cache-avec-un-service-worker), la requête de prélecture elle-même peut encore être en cours.

À des fins de démonstration, disons que la prélecture pour ce bundle prend deux secondes. Cependant, après une seconde d'affichage de la page, l'utilisateur clique sur le bouton. Dans un framework traditionnel, il y a de fortes chances pour qu'il ne se passe absolument rien ! Si le chargement du framework n'est pas terminé, l'appli n'est pas hydratée, l'appli n'a pas été re-rendue et l'écouteur d'événement n'a pas encore été ajouté au bouton. Malheureusement, l'interaction de l'utilisateur serait tout simplement perdue sur un framework utilisant l'hydratation.

Cependant, avec la prélecture et la mise en cache de Qwik, si l'utilisateur a cliqué sur le bouton, et que nous avons déjà commencé une requête il y a une seconde, et qu'il reste une seconde avant qu'elle ne soit complètement reçue, alors l'utilisateur final n'a qu'une seconde à attendre. N'oubliez pas qu'il dispose d'une connexion 3G lente pour cette démonstration. Heureusement, l'utilisateur a déjà reçu le rendu complet de la page d'accueil, donc il voit déjà une page complète. Ensuite, il ne précharge que les parties de l'appli avec lesquelles il peut interagir, et sa connexion lente n'est dédiée qu'à ce(s) bundle(s). Cela contraste avec la lenteur de leur connexion qui charge toutes les applications, juste pour exécuter l'écouteur unique.

Qwik est capable d'intercepter les requêtes pour des bundles connus, et si un préchargement est déjà en cours, et qu'ensuite un utilisateur demande le même bundle, il s'assurera que la seconde requête est capable de réutiliser la première, qui peut déjà être chargée. Faire tout cela avec le [link](/qwikcity/advanced/prefetching/index.mdx#mise-en-cache-des-paires-de-requêtes-et-de-réponses#known-issues-with-link) montre aussi pourquoi Qwik a préféré ne pas le faire par défaut, mais plutôt utiliser l'[API de mise en cache](/qwikcity/advanced/prefetching/index.mdx#mise-en-cache-des-paires-de-requêtes-et-de-réponses).

### Réduire les effets en cascade du réseau

On parle d'effet en cascade sur le réseau lorsque de nombreuses requêtes arrivent les unes après les autres, comme les marches d'un escalier, plutôt qu'en parallèle. Une cascade de requêtes réseau nuit généralement aux performances car elle augmente le temps nécessaire au chargement de tous les modules, alors que le chargement de chaque module débute en même temps.

Voici un exemple avec trois modules : A, B et C. Le module A importe B, et B importe C. C'est le document HTML qui démarre la cascade en demandant tout d'abord le module A.

```ts
import './b.js';
console.log('Module A');
```

```ts
import './c.js';
console.log('Module B');
```

```ts
console.log('Module C');
```

```html
<script type="module" src="./a.js"></script>
```

Dans cet exemple, lorsque le module A est appelé pour la première fois, le navigateur ne sait pas qu'il doit également demander les modules B et C. Il ne sait même pas qu'il doit commencer à demander le module B avant que le module A ne soit terminé. Il ne sait même pas qu'il doit commencer à demander le module `B`, seulement APRÈS que le module `A` ait fini de se charger. Il s'agit d'un problème courant dans la mesure où le navigateur ne sait pas à l'avance ce qu'il doit commencer à demander, jusqu'à ce que le chargement de chaque module soit terminé.

Cependant, comme notre service worker contient un graphe de modules généré à partir du manifeste, nous connaissons tous les modules qui seront demandés ensuite. Ainsi, lors d'une interaction avec l'utilisateur ou d'une recherche préalable d'un bundle, le navigateur lance la demande de tous les bundles qui seront demandés. Cela nous permet de réduire considérablement le temps nécessaire pour demander tous les bundles.
